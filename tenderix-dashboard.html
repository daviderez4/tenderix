<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tenderix - ×œ×•×— ×‘×§×¨×”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            min-height: 100vh;
            color: #e2e8f0;
        }

        .dashboard-layout {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: rgba(15, 23, 42, 0.95);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 24px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            backdrop-filter: blur(20px);
        }

        .sidebar-logo {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 40px;
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .sidebar-nav {
            list-style: none;
        }

        .sidebar-nav li {
            margin-bottom: 8px;
        }

        .sidebar-nav a {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            color: rgba(255,255,255,0.6);
            text-decoration: none;
            border-radius: 12px;
            transition: all 0.3s;
            font-size: 15px;
        }

        .sidebar-nav a:hover,
        .sidebar-nav a.active {
            background: rgba(96, 165, 250, 0.1);
            color: #60a5fa;
        }

        .sidebar-nav a.active {
            background: linear-gradient(135deg, rgba(96,165,250,0.2) 0%, rgba(167,139,250,0.2) 100%);
            border: 1px solid rgba(96,165,250,0.3);
        }

        .sidebar-user {
            position: absolute;
            bottom: 24px;
            left: 24px;
            right: 24px;
            padding: 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sidebar-user:hover {
            background: rgba(255,255,255,0.1);
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: 500;
            color: #f1f5f9;
        }

        .user-email {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-right: 280px;
            padding: 32px;
        }

        /* Header */
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        .header-title h1 {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #f1f5f9 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header-title p {
            color: rgba(255,255,255,0.5);
            font-size: 15px;
        }

        .header-actions {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e2e8f0;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            margin-bottom: 40px;
        }

        @media (max-width: 1400px) {
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
        }

        @media (max-width: 768px) {
            .stats-grid { grid-template-columns: 1fr; }
            .main-content { margin-right: 0; padding: 16px; }
            .sidebar { display: none; }
        }

        .stat-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 28px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            background: rgba(255,255,255,0.08);
            border-color: rgba(96,165,250,0.3);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .stat-icon {
            width: 56px;
            height: 56px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }

        .stat-icon.blue { background: rgba(59, 130, 246, 0.2); }
        .stat-icon.green { background: rgba(34, 197, 94, 0.2); }
        .stat-icon.yellow { background: rgba(234, 179, 8, 0.2); }
        .stat-icon.purple { background: rgba(139, 92, 246, 0.2); }

        .stat-value {
            font-size: 40px;
            font-weight: 700;
            color: #f1f5f9;
            margin-bottom: 4px;
        }

        .stat-label {
            color: rgba(255,255,255,0.5);
            font-size: 14px;
        }

        /* Content Grid */
        .content-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
        }

        @media (max-width: 1200px) {
            .content-grid { grid-template-columns: 1fr; }
        }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .card-header {
            padding: 24px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .card-body {
            padding: 24px;
        }

        /* Tender List */
        .tender-list {
            list-style: none;
        }

        .tender-item {
            display: flex;
            align-items: center;
            padding: 20px;
            margin-bottom: 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s;
        }

        .tender-item:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(96,165,250,0.3);
            transform: translateX(-4px);
        }

        .tender-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 16px;
        }

        .tender-status.active { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        .tender-status.pending { background: #eab308; box-shadow: 0 0 10px #eab308; }
        .tender-status.analyzing { background: #06b6d4; box-shadow: 0 0 10px #06b6d4; }
        .tender-status.draft { background: #64748b; }

        .tender-info {
            flex: 1;
        }

        .tender-name {
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 6px;
            font-size: 16px;
        }

        .tender-meta {
            font-size: 13px;
            color: rgba(255,255,255,0.5);
        }

        .tender-value {
            text-align: left;
        }

        .tender-amount {
            font-weight: 700;
            color: #22c55e;
            font-size: 16px;
        }

        .tender-deadline {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            margin-top: 4px;
        }

        .tender-deadline.urgent {
            color: #f87171;
        }

        /* Activity List */
        .activity-list {
            list-style: none;
        }

        .activity-item {
            display: flex;
            gap: 16px;
            padding: 16px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: rgba(59,130,246,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .activity-text {
            color: #e2e8f0;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .activity-time {
            color: rgba(255,255,255,0.4);
            font-size: 12px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 40px;
            color: rgba(255,255,255,0.5);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 18px;
            margin-bottom: 12px;
            color: #e2e8f0;
        }

        .empty-state-subtext {
            font-size: 14px;
            color: rgba(255,255,255,0.4);
            margin-bottom: 24px;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Upload Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 24px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: #f1f5f9;
        }

        .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #e2e8f0;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: rgba(239,68,68,0.2);
            color: #f87171;
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed rgba(96,165,250,0.3);
            border-radius: 20px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(59,130,246,0.05);
        }

        .upload-zone:hover,
        .upload-zone.drag-over {
            border-color: #60a5fa;
            background: rgba(59,130,246,0.1);
        }

        .upload-zone-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-zone-text {
            font-size: 18px;
            color: #e2e8f0;
            margin-bottom: 12px;
        }

        .upload-zone-hint {
            font-size: 14px;
            color: rgba(255,255,255,0.5);
        }

        .upload-progress {
            text-align: center;
        }

        .upload-progress .spinner {
            margin: 0 auto 20px;
        }

        .upload-progress p {
            color: #60a5fa;
            font-size: 16px;
        }

        /* Form Group */
        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #e2e8f0;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 14px 18px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            color: #f1f5f9;
            font-size: 15px;
            transition: all 0.3s;
        }

        .form-input:focus {
            outline: none;
            border-color: #60a5fa;
            background: rgba(255,255,255,0.08);
        }

        .form-input::placeholder {
            color: rgba(255,255,255,0.3);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 24px;
            left: 24px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .toast {
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(10px);
            animation: slideIn 0.3s ease;
            min-width: 300px;
        }

        .toast.success { border-color: rgba(34,197,94,0.3); }
        .toast.error { border-color: rgba(239,68,68,0.3); }
        .toast.info { border-color: rgba(59,130,246,0.3); }

        .toast-icon {
            font-size: 24px;
        }

        .toast-message {
            flex: 1;
            color: #e2e8f0;
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* File input hidden */
        .file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="dashboard-layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-logo">Tenderix</div>
            <nav>
                <ul class="sidebar-nav">
                    <li><a href="tenderix-dashboard.html" class="active">ğŸ“Š ×œ×•×— ×‘×§×¨×”</a></li>
                    <li><a href="tenderix-dashboard.html">ğŸ“‹ ××›×¨×–×™×</a></li>
                    <li><a href="tenderix-company-profile.html">ğŸ¢ ×¤×¨×•×¤×™×œ ×—×‘×¨×”</a></li>
                    <li><a href="tenderix-analytics.html">ğŸ“ˆ ×“×•×—×•×ª</a></li>
                    <li><a href="tenderix-settings.html">âš™ï¸ ×”×’×“×¨×•×ª</a></li>
                </ul>
            </nav>
            <div class="sidebar-user" id="sidebar-user">
                <div class="user-avatar" id="user-avatar">?</div>
                <div class="user-info">
                    <div class="user-name" id="user-name">Loading...</div>
                    <div class="user-email" id="user-email"></div>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="dashboard-header">
                <div class="header-title">
                    <h1>×œ×•×— ×‘×§×¨×”</h1>
                    <p id="current-date"></p>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" id="new-tender-btn">
                        â• ××›×¨×– ×—×“×©
                    </button>
                </div>
            </header>

            <!-- Stats -->
            <section class="stats-grid">
                <div class="stat-card">
                    <div class="stat-header">
                        <div>
                            <div class="stat-value" id="stat-total">0</div>
                            <div class="stat-label">×¡×”"×› ××›×¨×–×™×</div>
                        </div>
                        <div class="stat-icon blue">ğŸ“‹</div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-header">
                        <div>
                            <div class="stat-value" id="stat-active">0</div>
                            <div class="stat-label">×¤×¢×™×œ×™×</div>
                        </div>
                        <div class="stat-icon green">âœ“</div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-header">
                        <div>
                            <div class="stat-value" id="stat-pending">0</div>
                            <div class="stat-label">×××ª×™× ×™× ×œ×”×—×œ×˜×”</div>
                        </div>
                        <div class="stat-icon yellow">â³</div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-header">
                        <div>
                            <div class="stat-value" id="stat-value">â‚ª0</div>
                            <div class="stat-label">×©×•×•×™ ×¦×¤×™</div>
                        </div>
                        <div class="stat-icon purple">ğŸ’°</div>
                    </div>
                </div>
            </section>

            <!-- Content Grid -->
            <div class="content-grid">
                <!-- Tenders List -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">××›×¨×–×™× ××—×¨×•× ×™×</h2>
                        <button class="btn btn-secondary">×”×¦×’ ×”×›×œ</button>
                    </div>
                    <div class="card-body">
                        <ul class="tender-list" id="tender-list">
                            <li class="loading"><div class="spinner"></div></li>
                        </ul>
                    </div>
                </div>

                <!-- Side Panel -->
                <div class="side-panel">
                    <div class="card" style="margin-bottom: 24px;">
                        <div class="card-header">
                            <h2 class="card-title">×”×¢×œ××” ××”×™×¨×”</h2>
                        </div>
                        <div class="card-body">
                            <div class="upload-zone" id="quick-upload-zone">
                                <div class="upload-zone-icon">ğŸ“„</div>
                                <div class="upload-zone-text">×’×¨×•×¨ ×§×•×‘×¥ ××›×¨×– ×œ×›××Ÿ</div>
                                <div class="upload-zone-hint">PDF, Word, Excel ×¢×“ 50MB</div>
                            </div>
                            <input type="file" id="quick-file-input" class="file-input" accept=".pdf,.doc,.docx,.xls,.xlsx">
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">×¤×¢×™×œ×•×ª ××—×¨×•× ×”</h2>
                        </div>
                        <div class="card-body">
                            <ul class="activity-list" id="activity-list">
                                <li class="loading"><div class="spinner"></div></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Upload Modal -->
    <div class="modal-overlay" id="upload-modal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">×”×¢×œ××ª ××›×¨×– ×—×“×©</h2>
                <button class="modal-close" id="close-modal">&times;</button>
            </div>

            <div class="upload-zone" id="modal-upload-zone">
                <div class="upload-zone-icon">ğŸ“¤</div>
                <div class="upload-zone-text">×’×¨×•×¨ ×•×©×—×¨×¨ ××¡××›×™ ××›×¨×–</div>
                <div class="upload-zone-hint">××• ×œ×—×¥ ×œ×‘×—×™×¨×ª ×§×‘×¦×™×</div>
            </div>
            <input type="file" id="modal-file-input" class="file-input" accept=".pdf,.doc,.docx,.xls,.xlsx" multiple>

            <div class="form-group" style="margin-top: 24px;">
                <label>×©× ×”××›×¨×– (××•×¤×¦×™×•× ×œ×™)</label>
                <input type="text" class="form-input" id="tender-name-input" placeholder="×™×–×•×”×” ××•×˜×•××˜×™×ª ××”××¡××š">
            </div>

            <button class="btn btn-primary" style="width: 100%; margin-top: 16px;" id="start-analysis-btn">
                ğŸš€ ×”×ª×—×œ × ×™×ª×•×—
            </button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="js/config.js"></script>
    <script src="js/api.js"></script>
    <script src="js/auth.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const N8N_WEBHOOK = 'https://daviderez.app.n8n.cloud/webhook';

        // PDF.js worker setup
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // Use global supabase from config.js via getSupabase()
        let selectedFile = null;

        // ============================================
        // PDF TEXT EXTRACTION
        // ============================================
        async function extractTextFromPDF(file) {
            console.log('[PDF] Starting text extraction from:', file.name);

            if (typeof pdfjsLib === 'undefined') {
                console.error('[PDF] PDF.js not loaded');
                return '';
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                console.log('[PDF] Document loaded, pages:', pdf.numPages);

                let fullText = '';
                const maxPages = Math.min(pdf.numPages, 50); // Limit to 50 pages

                for (let i = 1; i <= maxPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';
                }

                console.log('[PDF] Extracted', fullText.length, 'characters');
                return fullText;
            } catch (error) {
                console.error('[PDF] Extraction error:', error);
                return '';
            }
        }

        // ============================================
        // TENDER METADATA PARSING
        // ============================================
        function parseTenderMetadata(text, fileName) {
            console.log('[Parse] Parsing metadata from', text.length, 'chars');

            const parseField = (patterns) => {
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        const value = match[1].trim();
                        if (value.length > 0 && value.length < 200) return value;
                    }
                }
                return null;
            };

            const parseDate = (patterns) => {
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        // Try to parse Hebrew date format DD/MM/YYYY or DD.MM.YYYY
                        const dateStr = match[1].trim();
                        const parts = dateStr.split(/[\.\/\-]/);
                        if (parts.length >= 3) {
                            const day = parseInt(parts[0]);
                            const month = parseInt(parts[1]) - 1;
                            let year = parseInt(parts[2]);
                            if (year < 100) year += 2000;
                            const date = new Date(year, month, day);
                            if (!isNaN(date.getTime())) {
                                return date.toISOString();
                            }
                        }
                    }
                }
                return null;
            };

            const parseAmount = (patterns) => {
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        let value = parseFloat(match[1].replace(/,/g, ''));
                        if (text.substring(match.index, match.index + 50).includes('××™×œ×™×•×Ÿ')) {
                            value *= 1000000;
                        } else if (text.substring(match.index, match.index + 50).includes('××œ×£')) {
                            value *= 1000;
                        }
                        return value;
                    }
                }
                return null;
            };

            // Parse percentage for scoring weights
            const parsePercentage = (patterns) => {
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        const value = parseInt(match[1].replace('%', ''));
                        if (value >= 0 && value <= 100) return value;
                    }
                }
                return null;
            };

            // Parse contract period in months
            const parseContractPeriod = () => {
                // Look for period patterns
                const patterns = [
                    /×ª×§×•×¤×ª?\s*(?:×”)?×”×ª×§×©×¨×•×ª\s*[:\-]?\s*(\d+)\s*(?:×—×•×“×©|×—×•×“×©×™×)/i,
                    /×ª×§×•×¤×”\s*[:\-]?\s*(\d+)\s*(?:×—×•×“×©|×—×•×“×©×™×)/i,
                    /×œ××©×š\s*(\d+)\s*(?:×—×•×“×©|×—×•×“×©×™×)/i,
                    /×ª×§×•×¤×ª?\s*(?:×”)?×”×ª×§×©×¨×•×ª\s*[:\-]?\s*(\d+)\s*×©× /i,
                    /×œ××©×š\s*(\d+)\s*×©× /i,
                ];
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        let months = parseInt(match[1]);
                        // If matched "×©× " (years), convert to months
                        if (pattern.toString().includes('×©× ')) {
                            months *= 12;
                        }
                        return months;
                    }
                }
                return null;
            };

            const metadata = {
                tender_number: parseField([
                    /××›×¨×–\s*(?:××¡['×³]?|××¡×¤×¨|×¤×•××‘×™)?\s*[:\-]?\s*([\d\/\-\.]+)/i,
                    /××¡×¤×¨\s*(?:×”)?××›×¨×–\s*[:\-]?\s*([\d\/\-\.]+)/i,
                    /××›×¨×–\s+(\d+[\d\/\-\.]*)/i,
                ]),
                tender_name: parseField([
                    /×©×\s*(?:×”)?××›×¨×–\s*[:\-]?\s*([^\n]{5,100})/i,
                    /××›×¨×–\s+(?:×œ|×”)?([^\n]{10,100})/i,
                    /× ×•×©×\s*(?:×”)?××›×¨×–\s*[:\-]?\s*([^\n]{5,100})/i,
                ]) || fileName.replace(/\.[^/.]+$/, ''),
                issuing_body: parseField([
                    /(?:×’×•×£|×’×•×¨×)\s*××–××™×Ÿ\s*[:\-]?\s*([^\n]{3,80})/i,
                    /×”××–××™×Ÿ\s*[:\-]?\s*([^\n]{3,80})/i,
                    /×¢×™×¨×™×™×ª?\s+([^\n]{3,50})/i,
                    /××©×¨×“\s+([^\n]{3,50})/i,
                    /×—×‘×¨×ª?\s+([^\n]{3,50})/i,
                ]),
                submission_deadline: parseDate([
                    /××•×¢×“\s*(?:××—×¨×•×Ÿ\s*)?(?:×œ)?×”×’×©×”?\s*[:\-]?\s*([\d]{1,2}[\.\/\-][\d]{1,2}[\.\/\-][\d]{2,4})/i,
                    /×œ×”×’×™×©\s*×¢×“\s*[:\-]?\s*([\d]{1,2}[\.\/\-][\d]{1,2}[\.\/\-][\d]{2,4})/i,
                    /×ª××¨×™×š\s*×”×’×©×”\s*[:\-]?\s*([\d]{1,2}[\.\/\-][\d]{1,2}[\.\/\-][\d]{2,4})/i,
                ]),
                clarification_deadline: parseDate([
                    /××•×¢×“\s*(?:××—×¨×•×Ÿ\s*)?(?:×œ)?(?:×©××œ×•×ª|×”×‘×”×¨×•×ª)\s*[:\-]?\s*([\d]{1,2}[\.\/\-][\d]{1,2}[\.\/\-][\d]{2,4})/i,
                    /×©××œ×•×ª\s*(?:×”×‘×”×¨×”)?\s*×¢×“\s*[:\-]?\s*([\d]{1,2}[\.\/\-][\d]{1,2}[\.\/\-][\d]{2,4})/i,
                ]),
                estimated_value: parseAmount([
                    /(?:××•××“×Ÿ|×”×™×§×£|×©×•×•×™)\s*[:\-]?\s*([\d,\.]+)/i,
                    /×ª×§×¦×™×‘\s*[:\-]?\s*([\d,\.]+)/i,
                ]),
                guarantee_amount: parseAmount([
                    /×¢×¨×‘×•×ª\s*(?:×”×¦×¢×”|×‘× ×§××™×ª)?\s*[:\-]?\s*([\d,\.]+)/i,
                    /×¡×›×•×\s*(?:×”)?×¢×¨×‘×•×ª\s*[:\-]?\s*([\d,\.]+)/i,
                ]),
                // Module 1.2: Scoring weights (××œ×™×¦×—: ×—×©×•×‘!)
                quality_weight: parsePercentage([
                    /××©×§×œ\s*(?:×”)?××™×›×•×ª\s*[:\-]?\s*(\d+)%?/i,
                    /××™×›×•×ª\s*[:\-]?\s*(\d+)%/i,
                    /(\d+)%\s*××™×›×•×ª/i,
                    /× ×™×§×•×“\s*××™×›×•×ª\s*[:\-]?\s*(\d+)/i,
                ]),
                price_weight: parsePercentage([
                    /××©×§×œ\s*(?:×”)?××—×™×¨\s*[:\-]?\s*(\d+)%?/i,
                    /××—×™×¨\s*[:\-]?\s*(\d+)%/i,
                    /(\d+)%\s*××—×™×¨/i,
                    /× ×™×§×•×“\s*××—×™×¨\s*[:\-]?\s*(\d+)/i,
                ]),
                // Contract period in months
                contract_duration_months: parseContractPeriod(),
            };

            // Calculate complementary weight if one is found
            if (metadata.quality_weight && !metadata.price_weight) {
                metadata.price_weight = 100 - metadata.quality_weight;
            } else if (metadata.price_weight && !metadata.quality_weight) {
                metadata.quality_weight = 100 - metadata.price_weight;
            }

            console.log('[Parse] Extracted metadata:', metadata);
            return metadata;
        }

        // ============================================
        // GATE CONDITIONS EXTRACTION
        // ============================================
        async function extractGateConditions(tenderId, text) {
            console.log('[Gates] Extracting gate conditions for tender:', tenderId);

            const supabase = getSupabase();
            if (!supabase) return { success: false, count: 0 };

            const extractedConditions = [];
            let conditionNumber = 1;
            const extractedTexts = new Set();

            const gatePatterns = [
                /×ª× ××™\s*×¡×£\s*(?:××¡['×³]?|××¡×¤×¨)?\s*(\d+(?:\.\d+)?)\s*[-â€“:]\s*([^\n]+)/gi,
                /(\d+(?:\.\d+)?)\s*[.\)]\s*(?:×¢×œ\s*×”××¦×™×¢|× ×“×¨×©|×—×•×‘×”|×™×©\s*×œ×”×¦×™×’|×™×©\s*×œ×¦×¨×£)\s*([^\n]+)/gi,
                /×¢×œ\s*×”××¦×™×¢\s*(?:×œ×”×™×•×ª|×œ×”×•×›×™×—|×œ×”×¦×™×’|×œ×¦×¨×£|×œ×”××¦×™×|×œ×¢××•×“)\s*([^\n]{10,200})/gi,
                /×ª× ××™\s*×—×•×‘×”\s*[-â€“:]\s*([^\n]+)/gi,
                /×“×¨×™×©×•×ª?\s*×¡×£\s*[-â€“:]\s*([^\n]+)/gi,
            ];

            for (const pattern of gatePatterns) {
                let match;
                pattern.lastIndex = 0;
                while ((match = pattern.exec(text)) !== null) {
                    const conditionText = (match[2] || match[1]).trim();

                    if (conditionText.length < 15 || extractedTexts.has(conditionText.substring(0, 50))) {
                        continue;
                    }
                    extractedTexts.add(conditionText.substring(0, 50));

                    let requirementType = 'OTHER';
                    if (/× ×™×¡×™×•×Ÿ|×¤×¨×•×™×§×˜|×‘×™×¦×•×¢|×¢×‘×•×“×”|×©× [×”×•×ª]/.test(conditionText)) {
                        requirementType = 'EXPERIENCE';
                    } else if (/××—×–×•×¨|×”×›× ×¡×•×ª|×”×•×Ÿ|×›×¡×¤×™|×¤×™× × ×¡|×¢×¨×‘×•×ª/.test(conditionText)) {
                        requirementType = 'FINANCIAL';
                    } else if (/×ª×¢×•×“×”|×¨×™×©×™×•×Ÿ|×”×¡××›×”|ISO|×¡×™×•×•×’|××™×©×•×¨/.test(conditionText)) {
                        requirementType = 'CERTIFICATION';
                    } else if (/×× ×”×œ|×¦×•×•×ª|×¢×•×‘×“|××”× ×“×¡|×™×•×¢×¥/.test(conditionText)) {
                        requirementType = 'PERSONNEL';
                    }

                    const isMandatory = /×—×•×‘×”|×ª× ××™\s*×¡×£|×¤×•×¡×œ|×œ×”×’×™×©|× ×“×¨×©/.test(conditionText) ||
                                       /×¢×œ\s*×”××¦×™×¢/.test(match[0]);

                    extractedConditions.push({
                        tender_id: tenderId,
                        condition_number: String(conditionNumber),
                        condition_text: conditionText,
                        condition_type: 'GATE',
                        is_mandatory: isMandatory,
                        requirement_type: requirementType,
                        status: 'UNKNOWN',
                    });
                    conditionNumber++;
                }
            }

            console.log('[Gates] Found', extractedConditions.length, 'conditions');

            // Save to database
            let savedCount = 0;
            for (const condition of extractedConditions.slice(0, 30)) {
                try {
                    const { error } = await supabase
                        .from('gate_conditions')
                        .insert(condition);
                    if (!error) savedCount++;
                } catch (err) {
                    console.error('[Gates] Error saving condition:', err);
                }
            }

            console.log('[Gates] Saved', savedCount, 'conditions to database');
            return { success: savedCount > 0, count: savedCount };
        }

        // ============================================
        // DOCUMENT TYPE DETECTION (Module 1.1)
        // ============================================
        function detectDocumentType(text, fileName) {
            console.log('[DocType] Detecting document type...');

            const lowerText = text.toLowerCase();
            const lowerFileName = fileName.toLowerCase();

            // Detection patterns for each document type
            const patterns = {
                TENDER_INVITATION: {
                    // ×”×–×× ×” ×œ×”×¦×™×¢ ×”×¦×¢×•×ª - contains ×ª× ××™ ×¡×£
                    indicators: [
                        '×”×–×× ×” ×œ×”×¦×™×¢ ×”×¦×¢×•×ª',
                        '×”×–×× ×” ×œ×”×’×™×© ×”×¦×¢×•×ª',
                        '××›×¨×– ×¤×•××‘×™',
                        '×ª× ××™ ×¡×£',
                        '×ª× ××™ ×”×¡×£',
                        '×¨×©××™ ×œ×”×©×ª×ª×£',
                        '×–×›××™ ×œ×”×©×ª×ª×£'
                    ],
                    weight: 0
                },
                TECHNICAL_SPECIFICATION: {
                    // ××¤×¨×˜ ×˜×›× ×™
                    indicators: [
                        '××¤×¨×˜ ×˜×›× ×™',
                        '×“×¨×™×©×•×ª ×˜×›× ×™×•×ª',
                        '××¤×¨×˜ ××™×•×—×“',
                        '×ª×§× ×™×',
                        'SLA',
                        '×¨××ª ×©×™×¨×•×ª'
                    ],
                    weight: 0
                },
                BILL_OF_QUANTITIES: {
                    // ×›×ª×‘ ×›××•×™×•×ª BOQ
                    indicators: [
                        '×›×ª×‘ ×›××•×™×•×ª',
                        '×›×ª×‘ ×”×›××•×™×•×ª',
                        'BOQ',
                        '×¤×¨×™×˜ ××¡\'',
                        '×™×—×™×“×ª ××™×“×”',
                        '×›××•×ª',
                        '××—×™×¨ ×œ×™×—×™×“×”',
                        '×¡×”"×›'
                    ],
                    weight: 0
                },
                CONTRACT: {
                    // ×—×•×–×” ×”×ª×§×©×¨×•×ª
                    indicators: [
                        '×—×•×–×”',
                        '×”×¡×›× ×”×ª×§×©×¨×•×ª',
                        '×ª× ××™ ×”×”×ª×§×©×¨×•×ª',
                        '×ª× ××™× ×›×œ×œ×™×™×',
                        '×¦×“ ×\'',
                        '×¦×“ ×‘\'',
                        '×”×§×‘×œ×Ÿ ××ª×—×™×™×‘'
                    ],
                    weight: 0
                },
                CLARIFICATIONS: {
                    // ××¡××›×™ ×”×‘×”×¨×•×ª
                    indicators: [
                        '×”×‘×”×¨×•×ª',
                        '×©××œ×•×ª ×•×ª×©×•×‘×•×ª',
                        '××¢× ×” ×œ×©××œ×•×ª',
                        '×ª×©×•×‘×•×ª ×œ×”×‘×”×¨×•×ª',
                        '×©××œ×” ××¡\'',
                        '×ª×©×•×‘×”:'
                    ],
                    weight: 0
                },
                FORMS: {
                    // ×˜×¤×¡×™× ×œ××™×œ×•×™
                    indicators: [
                        '×˜×•×¤×¡',
                        '× ×¡×¤×—',
                        '×”×¦×”×¨×”',
                        '×›×ª×‘ ×”×ª×—×™×™×‘×•×ª',
                        '×¢×¨×‘×•×ª ×‘× ×§××™×ª',
                        '×œ××œ×',
                        '×—×ª×™××”:'
                    ],
                    weight: 0
                }
            };

            // Calculate weights based on indicator matches
            for (const [docType, config] of Object.entries(patterns)) {
                for (const indicator of config.indicators) {
                    if (lowerText.includes(indicator) || lowerFileName.includes(indicator)) {
                        config.weight += 1;
                    }
                }
            }

            // Find the type with highest weight
            let bestType = 'TENDER_INVITATION'; // default
            let maxWeight = 0;

            for (const [docType, config] of Object.entries(patterns)) {
                if (config.weight > maxWeight) {
                    maxWeight = config.weight;
                    bestType = docType;
                }
            }

            // Special cases based on filename
            if (lowerFileName.includes('boq') || lowerFileName.includes('×›××•×™×•×ª')) {
                bestType = 'BILL_OF_QUANTITIES';
            } else if (lowerFileName.includes('××¤×¨×˜')) {
                bestType = 'TECHNICAL_SPECIFICATION';
            } else if (lowerFileName.includes('×”×‘×”×¨×•×ª')) {
                bestType = 'CLARIFICATIONS';
            } else if (lowerFileName.includes('×—×•×–×”') || lowerFileName.includes('×”×¡×›×')) {
                bestType = 'CONTRACT';
            }

            console.log('[DocType] Detected type:', bestType, 'with weight:', maxWeight);
            return bestType;
        }

        // ============================================
        // MODULE 1.3: HEBREW TEXT NORMALIZATION
        // ============================================
        function normalizeHebrewText(text) {
            console.log('[Normalize] Normalizing Hebrew text...');

            let normalized = text;

            // Fix common typos
            const typoFixes = {
                '×™×›×•×œ×¦': '×™×›×•×œ×ª',
                '××¡×•×’×•×œ×ª': '××¡×•×’×œ×•×ª',
                '×”×¦××”': '×”×¦×¢×”',
                '××›×¨×–×–': '××›×¨×–',
                '×ª× ××™×™': '×ª× ××™',
                '×¤×¨×•×™×§×˜×˜': '×¤×¨×•×™×§×˜',
            };
            for (const [typo, fix] of Object.entries(typoFixes)) {
                normalized = normalized.replace(new RegExp(typo, 'g'), fix);
            }

            // Normalize synonyms to standard terms
            const synonyms = {
                '××¡×•×’×œ×•×ª': '×™×›×•×œ×ª',
                '×›×©×™×¨×•×ª': '×™×›×•×œ×ª',
                '×”×¡×ª×™×™×’×•×ª': '×”×‘×”×¨×”',
                '×§.××©× ×”': '×§×‘×œ×Ÿ ××©× ×”',
                '×§"×': '×§×‘×œ×Ÿ ××©× ×”',
            };
            for (const [synonym, standard] of Object.entries(synonyms)) {
                normalized = normalized.replace(new RegExp(synonym, 'g'), standard);
            }

            // Normalize numbers: "50 ××œ×©"×—" -> "50000000"
            normalized = normalized.replace(/(\d+)\s*××œ×©"×—/g, (match, num) => (parseInt(num) * 1000000).toString());
            normalized = normalized.replace(/(\d+)\s*××œ×™×•×Ÿ/g, (match, num) => (parseInt(num) * 1000000).toString());
            normalized = normalized.replace(/(\d+)\s*××œ×£/g, (match, num) => (parseInt(num) * 1000).toString());

            // Normalize currency symbols
            normalized = normalized.replace(/×©"×—/g, 'â‚ª');
            normalized = normalized.replace(/×©×§×œ/g, 'â‚ª');

            return normalized;
        }

        // ============================================
        // MODULE 1.4: DEFINITIONS EXTRACTION
        // ============================================
        function extractDefinitions(text) {
            console.log('[Definitions] Extracting tender definitions...');

            const definitions = [];

            // Pattern 1: "××•× ×—" - ×”×’×“×¨×”
            const pattern1 = /["×´]([^"×´]+)["×´]\s*[-â€“:]\s*([^\n]{10,200})/g;
            let match;
            while ((match = pattern1.exec(text)) !== null) {
                definitions.push({
                    term: match[1].trim(),
                    definition: match[2].trim(),
                    source: 'quoted_definition'
                });
            }

            // Pattern 2: Look for "×”×’×“×¨×•×ª" section
            const defSectionMatch = text.match(/(?:×¡×¢×™×£\s*)?×”×’×“×¨×•×ª([\s\S]{100,5000}?)(?=×¡×¢×™×£\s*\d|×¤×¨×§\s*\d|$)/i);
            if (defSectionMatch) {
                const defSection = defSectionMatch[1];
                // Extract items from definitions section
                const itemPattern = /(\d+\.\d*)\s*["×´]?([^"×´\n]+)["×´]?\s*[-â€“:]\s*([^\n]+)/g;
                while ((match = itemPattern.exec(defSection)) !== null) {
                    definitions.push({
                        term: match[2].trim(),
                        definition: match[3].trim(),
                        source: 'definitions_section',
                        section_number: match[1]
                    });
                }
            }

            // Pattern 3: Common tender terms
            const commonTerms = ['×¤×¨×•×™×§×˜ ×“×•××”', '×”××¦×™×¢', '×”××–××™×Ÿ', '× ×™×¡×™×•×Ÿ ×§×•×“×', '×ª× ××™ ×¡×£'];
            for (const term of commonTerms) {
                const termPattern = new RegExp(`${term}\\s*[-â€“:]\\s*([^\\n]{10,200})`, 'i');
                const termMatch = text.match(termPattern);
                if (termMatch) {
                    definitions.push({
                        term: term,
                        definition: termMatch[1].trim(),
                        source: 'inline_definition'
                    });
                }
            }

            console.log('[Definitions] Found', definitions.length, 'definitions');
            return definitions;
        }

        // ============================================
        // MODULE 1.5: TENDER CATEGORIZATION
        // ============================================
        function categorizeTender(text) {
            console.log('[Category] Categorizing tender...');

            const categories = {
                VIDEO_CCTV: {
                    keywords: ['××¦×œ××•×ª', 'CCTV', '×•×™×“××•', '××¢×§×‘', 'PTZ', 'LPR', '×–×™×”×•×™ ×œ×•×—×™×•×ª', '×× ×œ×™×˜×™×§×”'],
                    weight: 0
                },
                COMMUNICATIONS: {
                    keywords: ['×ª×§×©×•×¨×ª', '×¨×©×ª', '×¡×™×™×‘×¨', 'WiFi', '××œ×—×•×˜', '×¡×™×‘×™×', '××•×¤×˜×™'],
                    weight: 0
                },
                SOFTWARE: {
                    keywords: ['×ª×•×›× ×”', 'VMS', 'PSIM', '××¤×œ×™×§×¦×™×”', '×××©×§', 'API', '××¢×¨×›×ª × ×™×”×•×œ'],
                    weight: 0
                },
                ACCESS_CONTROL: {
                    keywords: ['×‘×§×¨×ª ×›× ×™×¡×”', '×©×¢×¨×™×', '×§×•×¨× ×›×¨×˜×™×¡×™×', '×‘×™×•××˜×¨×™', '×× ×¢×•×œ×™×'],
                    weight: 0
                },
                INFRASTRUCTURE: {
                    keywords: ['×ª×©×ª×™×ª', '×—×©××œ', '×›×‘×™×œ×”', '×¢×‘×•×“×•×ª ××–×¨×—×™×•×ª', '×¢××•×“×™×', '×—×¤×™×¨×”'],
                    weight: 0
                },
                CONSULTING: {
                    keywords: ['×™×™×¢×•×¥', '× ×™×”×•×œ ×¤×¨×•×™×§×˜×™×', '×¤×™×§×•×—', '×ª×›× ×•×Ÿ', '×”× ×“×¡×”'],
                    weight: 0
                },
                MAINTENANCE: {
                    keywords: ['×ª×—×–×•×§×”', '×©×™×¨×•×ª', '××—×–×§×”', 'SLA', '×ª×™×§×•× ×™×', '×ª××™×›×”'],
                    weight: 0
                }
            };

            const lowerText = text.toLowerCase();

            for (const [category, config] of Object.entries(categories)) {
                for (const keyword of config.keywords) {
                    if (lowerText.includes(keyword.toLowerCase())) {
                        config.weight += 1;
                    }
                }
            }

            // Find best category
            let bestCategory = 'OTHER';
            let maxWeight = 0;
            const matchedCategories = [];

            for (const [category, config] of Object.entries(categories)) {
                if (config.weight > 0) {
                    matchedCategories.push({ category, weight: config.weight });
                }
                if (config.weight > maxWeight) {
                    maxWeight = config.weight;
                    bestCategory = category;
                }
            }

            // If multiple categories match, it's COMBINED
            if (matchedCategories.length > 2) {
                bestCategory = 'COMBINED';
            }

            console.log('[Category] Best category:', bestCategory, 'Matched:', matchedCategories);
            return {
                primary: bestCategory,
                all: matchedCategories,
                technical_dictionary: getTechnicalDictionary(bestCategory)
            };
        }

        // Technical dictionary per category (Module C2)
        function getTechnicalDictionary(category) {
            const dictionaries = {
                VIDEO_CCTV: {
                    equivalents: {
                        '××¦×œ××ª ××‘×˜×—×”': ['××¦×œ××ª IP', '××¦×œ××ª ×¨×©×ª', '××¦×œ××ª ××¢×§×‘', '××¦×œ××ª ×ª× ×•×¢×”'],
                        '××¢×¨×›×ª × ×™×”×•×œ ×•×™×“××•': ['VMS', 'DVR', 'NVR', '××¢×¨×›×ª ×”×§×œ×˜×”'],
                    }
                },
                COMMUNICATIONS: {
                    equivalents: {
                        '×¨×©×ª ×ª×§×©×•×¨×ª': ['LAN', 'WAN', '×¨×©×ª ××§×•××™×ª', '×¨×©×ª × ×ª×•× ×™×'],
                        '×¦×™×•×“ ×ª×§×©×•×¨×ª': ['××ª×’', '× ×ª×‘', 'switch', 'router'],
                    }
                },
                SOFTWARE: {
                    equivalents: {
                        '××¢×¨×›×ª × ×™×”×•×œ': ['PSIM', 'VMS', 'BMS', '×ª×•×›× ×ª × ×™×”×•×œ'],
                    }
                },
                ACCESS_CONTROL: {
                    equivalents: {
                        '×‘×§×¨×ª ×›× ×™×¡×”': ['×§×•×¨× ×›×¨×˜×™×¡×™×', '××¢×¨×›×ª ×©×¢×¨×™×', '×‘×§×¨×ª ×’×™×©×”'],
                    }
                }
            };
            return dictionaries[category] || {};
        }

        // ============================================
        // MODULE 2.1 REBUILT: DEEP SENTENCE ANALYSIS FOR GATE CONDITIONS
        // High-quality extraction with semantic understanding
        // ============================================
        async function extractGateConditionsEnhanced(tenderId, text, definitions) {
            console.log('[Gates Deep Analysis] Starting high-quality extraction...');

            const supabase = getSupabase();
            if (!supabase) return { success: false, conditions: [] };

            // Step 1: Pre-process text with page markers
            const textWithPages = addPageMarkers(text);

            // Step 2: Find gate conditions section(s)
            const gateSections = findGateSections(textWithPages);
            console.log('[Gates Deep Analysis] Found', gateSections.length, 'gate sections');

            // Step 3: Deep sentence analysis
            const conditions = [];
            let conditionNumber = 1;
            const extractedSignatures = new Set(); // For deduplication

            // Process each gate section
            for (const section of gateSections) {
                const sectionConditions = analyzeGateSectionDeeply(
                    section,
                    conditionNumber,
                    tenderId,
                    definitions,
                    extractedSignatures
                );
                conditionNumber += sectionConditions.length;
                conditions.push(...sectionConditions);
            }

            // Step 4: Also scan full text for scattered requirements
            const scatteredConditions = scanForScatteredRequirements(
                textWithPages,
                conditionNumber,
                tenderId,
                definitions,
                extractedSignatures
            );
            conditions.push(...scatteredConditions);

            // Step 5: Extract advantage/scoring conditions
            const advantageConditions = extractAdvantageConditions(
                textWithPages,
                conditions.length + 1,
                tenderId,
                extractedSignatures
            );
            conditions.push(...advantageConditions);

            console.log('[Gates Deep Analysis] Total conditions found:', conditions.length);
            console.log('[Gates Deep Analysis] Mandatory:', conditions.filter(c => c.is_mandatory).length);
            console.log('[Gates Deep Analysis] Advantages:', conditions.filter(c => !c.is_mandatory).length);

            // Save to database with error handling
            // Only include columns that exist in the database schema
            let savedCount = 0;
            const errors = [];

            for (const condition of conditions) {
                try {
                    // Map to only known database columns
                    // Note: status should be 'UNKNOWN', 'MEETS', 'PARTIALLY_MEETS', 'DOES_NOT_MEET'
                    const dbRecord = {
                        tender_id: condition.tender_id,
                        condition_number: condition.condition_number,
                        condition_text: condition.condition_text,
                        condition_type: condition.condition_type || 'GATE',
                        is_mandatory: condition.is_mandatory ?? true,
                        requirement_type: condition.requirement_type,
                        required_amount: condition.required_amount || null,
                        required_count: condition.required_count || null,
                        required_years: condition.required_years || null,
                        source_page: condition.source_page || null,
                        source_section: condition.source_section || null,
                        status: 'UNKNOWN' // Initial status before company profile matching
                    };

                    const { error } = await supabase.from('gate_conditions').insert(dbRecord);
                    if (!error) {
                        savedCount++;
                    } else {
                        console.warn('[Gates] Insert error for condition', condition.condition_number, ':', error.message);
                        errors.push({ condition: condition.condition_number, error: error.message });
                    }
                } catch (err) {
                    console.error('[Gates] Exception saving condition', condition.condition_number, ':', err);
                    errors.push({ condition: condition.condition_number, error: err.message });
                }
            }

            if (errors.length > 0) {
                console.warn('[Gates Deep Analysis] Save errors:', errors.slice(0, 5));
            }

            return {
                success: savedCount > 0,
                count: savedCount,
                total: conditions.length,
                conditions
            };
        }

        // Add page markers to text for traceability
        function addPageMarkers(text) {
            // If text already has page markers, return as-is
            if (text.includes('[[PAGE:')) return text;

            // Estimate pages based on character count (~2500 chars per page for Hebrew)
            const CHARS_PER_PAGE = 2500;
            let result = '';
            let currentPage = 1;

            for (let i = 0; i < text.length; i++) {
                if (i > 0 && i % CHARS_PER_PAGE === 0) {
                    currentPage++;
                    result += `\n[[PAGE:${currentPage}]]\n`;
                }
                result += text[i];
            }

            return `[[PAGE:1]]\n${result}`;
        }

        // Find sections that contain gate conditions
        function findGateSections(text) {
            const sections = [];

            // Patterns to find gate condition sections
            const sectionPatterns = [
                /(?:×¤×¨×§|×¡×¢×™×£)[\s\S]{0,30}×ª× ××™\s*×¡×£[\s\S]{0,5000}?(?=(?:×¤×¨×§|×¡×¢×™×£)[\s\S]{0,30}(?!×ª× ××™\s*×¡×£)|$)/gi,
                /×ª× ××™\s*×¡×£\s*(?:×œ×”×©×ª×ª×¤×•×ª|×œ××›×¨×–|×—×•×‘×”)[\s\S]{0,8000}?(?=(?:×¤×¨×§|×¡×¢×™×£)[\s\S]{0,20}(?!×ª× ××™)|$)/gi,
                /(?:^|\n)[\d\.]+\s*[-â€“]?\s*×ª× ××™\s*×¡×£[\s\S]{0,6000}?(?=\n[\d\.]+\s*[-â€“]?\s*(?!×ª× ××™)|$)/gim
            ];

            for (const pattern of sectionPatterns) {
                pattern.lastIndex = 0;
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const sectionText = match[0];
                    // Avoid duplicates
                    const isDuplicate = sections.some(s =>
                        s.text.includes(sectionText.substring(0, 100)) ||
                        sectionText.includes(s.text.substring(0, 100))
                    );
                    if (!isDuplicate && sectionText.length > 100) {
                        sections.push({
                            text: sectionText,
                            startIndex: match.index,
                            page: extractPageFromPosition(text, match.index)
                        });
                    }
                }
            }

            // If no sections found, treat entire text as potential source
            if (sections.length === 0) {
                sections.push({
                    text: text,
                    startIndex: 0,
                    page: 1
                });
            }

            return sections;
        }

        // Extract page number from position in text
        function extractPageFromPosition(text, position) {
            const textBefore = text.substring(0, position);
            const pageMatches = textBefore.match(/\[\[PAGE:(\d+)\]\]/g);
            if (pageMatches && pageMatches.length > 0) {
                const lastMatch = pageMatches[pageMatches.length - 1];
                const num = lastMatch.match(/\d+/);
                return num ? parseInt(num[0]) : 1;
            }
            return Math.ceil(position / 2500) || 1;
        }

        // Deep analysis of a gate section - sentence by sentence
        function analyzeGateSectionDeeply(section, startNumber, tenderId, definitions, extractedSignatures) {
            const conditions = [];
            let conditionNumber = startNumber;

            // Split into meaningful segments (sentences/paragraphs)
            const segments = splitIntoSegments(section.text);

            let currentCondition = null;
            let currentPage = section.page;

            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const segmentText = segment.text.trim();

                // Update page if marker found
                const pageMatch = segmentText.match(/\[\[PAGE:(\d+)\]\]/);
                if (pageMatch) {
                    currentPage = parseInt(pageMatch[1]);
                    continue;
                }

                // Skip very short or header-only segments
                if (segmentText.length < 10) continue;

                // Analyze if this is a new requirement or continuation
                const analysis = analyzeSegmentSemantics(segmentText, currentCondition);

                if (analysis.isNewRequirement) {
                    // Save previous condition if exists
                    if (currentCondition && currentCondition.condition_text.length >= 20) {
                        const signature = createConditionSignature(currentCondition.condition_text);
                        if (!extractedSignatures.has(signature)) {
                            extractedSignatures.add(signature);
                            conditions.push(currentCondition);
                        }
                    }

                    // Start new condition
                    const quantitative = extractQuantitativeDataDeep(segmentText);
                    const bearer = identifyRequirementBearer(segmentText);

                    currentCondition = {
                        tender_id: tenderId,
                        condition_number: String(conditionNumber++),
                        condition_text: cleanConditionText(segmentText),
                        original_quote: segmentText.substring(0, 500),
                        condition_type: 'MANDATORY',
                        is_mandatory: true,
                        requirement_type: classifyRequirementTypeDeep(segmentText),
                        required_amount: quantitative.amount,
                        required_count: quantitative.count,
                        required_years: quantitative.years,
                        required_turnover: quantitative.turnover,
                        entity_type: bearer.entity,
                        source_page: currentPage,
                        source_section: extractSectionNumber(segmentText) || section.sectionNumber,
                        keywords: analysis.keywords,
                        status: 'PENDING'
                    };
                } else if (analysis.isContinuation && currentCondition) {
                    // Append to current condition
                    currentCondition.condition_text += ' ' + cleanConditionText(segmentText);

                    // Re-extract quantitative data with fuller text
                    const quantitative = extractQuantitativeDataDeep(currentCondition.condition_text);
                    if (quantitative.amount) currentCondition.required_amount = quantitative.amount;
                    if (quantitative.count) currentCondition.required_count = quantitative.count;
                    if (quantitative.years) currentCondition.required_years = quantitative.years;
                    if (quantitative.turnover) currentCondition.required_turnover = quantitative.turnover;
                }
            }

            // Don't forget last condition
            if (currentCondition && currentCondition.condition_text.length >= 20) {
                const signature = createConditionSignature(currentCondition.condition_text);
                if (!extractedSignatures.has(signature)) {
                    extractedSignatures.add(signature);
                    conditions.push(currentCondition);
                }
            }

            return conditions;
        }

        // Split text into meaningful segments
        function splitIntoSegments(text) {
            const segments = [];

            // Split by numbered items first
            const numberedPattern = /(?:^|\n)\s*(?:(\d+(?:\.\d+)*)[.\)\-â€“]\s*|([×-×ª])[.\)\-]\s*)/gm;
            let lastIndex = 0;
            let match;

            numberedPattern.lastIndex = 0;
            while ((match = numberedPattern.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    const prevText = text.substring(lastIndex, match.index).trim();
                    if (prevText.length > 0) {
                        segments.push({ text: prevText, numbered: false });
                    }
                }
                lastIndex = match.index;
            }

            // Add remaining text
            if (lastIndex < text.length) {
                segments.push({ text: text.substring(lastIndex).trim(), numbered: false });
            }

            // If no numbered items found, split by sentences
            if (segments.length <= 1) {
                const sentences = text.split(/(?<=[.!?:]\s)|(?=\n\s*[-â€¢])/);
                return sentences.map(s => ({ text: s.trim(), numbered: false })).filter(s => s.text.length > 0);
            }

            return segments;
        }

        // Analyze segment semantics - is it a new requirement or continuation?
        function analyzeSegmentSemantics(text, currentCondition) {
            const result = {
                isNewRequirement: false,
                isContinuation: false,
                keywords: []
            };

            const normalizedText = text.toLowerCase();

            // Strong indicators of NEW requirement
            const newRequirementIndicators = [
                { pattern: /×ª× ××™\s*×¡×£/, weight: 10, keyword: '×ª× ××™ ×¡×£' },
                { pattern: /×¢×œ\s*×”××¦×™×¢\s*(?:×œ×”×™×•×ª|×œ×”×•×›×™×—|×œ×”×¦×™×’|×œ×¦×¨×£|×œ×”××¦×™×)/, weight: 9, keyword: '×¢×œ ×”××¦×™×¢' },
                { pattern: /× ×“×¨×©\s*(?:×›×™|×©|×œ)/, weight: 8, keyword: '× ×“×¨×©' },
                { pattern: /×—×•×‘×”\s*(?:×œ×”×¦×™×’|×œ×¦×¨×£|×œ×”×•×›×™×—)/, weight: 9, keyword: '×—×•×‘×”' },
                { pattern: /×”××¦×™×¢\s*×™×¦×™×’/, weight: 8, keyword: '×”××¦×™×¢ ×™×¦×™×’' },
                { pattern: /×™×©\s*×œ×”×•×›×™×—/, weight: 7, keyword: '×™×© ×œ×”×•×›×™×—' },
                { pattern: /(?:^|\n)\s*\d+[.\)]\s*/, weight: 6, keyword: '××¡×¤×•×¨' },
                { pattern: /× ×™×¡×™×•×Ÿ\s*(?:×‘|×©×œ|××•×›×—)/, weight: 7, keyword: '× ×™×¡×™×•×Ÿ' },
                { pattern: /×¨×™×©×™×•×Ÿ|×”×™×ª×¨|××™×©×•×¨/, weight: 7, keyword: '×¨×™×©×™×•×Ÿ/××™×©×•×¨' },
                { pattern: /××—×–×•×¨\s*(?:×›×¡×¤×™|×©× ×ª×™|×¢×¡×§×™)/, weight: 8, keyword: '××—×–×•×¨' },
                { pattern: /×”×¡××›×”|×ª×§×Ÿ|ISO/, weight: 7, keyword: '×”×¡××›×”' },
                { pattern: /×¢×¨×‘×•×ª\s*(?:×‘× ×§××™×ª|××›×¨×–|×‘×™×¦×•×¢)/, weight: 8, keyword: '×¢×¨×‘×•×ª' },
                { pattern: /×¦×•×•×ª\s*(?:××§×¦×•×¢×™|××™× ×™××œ×™)/, weight: 6, keyword: '×¦×•×•×ª' },
                { pattern: /××”× ×“×¡|×™×•×¢×¥|×× ×”×œ\s*×¤×¨×•×™×§×˜/, weight: 6, keyword: '×›×•×— ××“×' }
            ];

            // Continuation indicators
            const continuationIndicators = [
                { pattern: /^(?:×•|××•|×›×•×œ×œ|×œ×¨×‘×•×ª|×•×›×Ÿ|×‘× ×•×¡×£)/, weight: 5 },
                { pattern: /^(?:××ª|×©×œ|×¢×‘×•×¨|×‘|×|×œ)/, weight: 3 },
                { pattern: /^[-â€“â€¢]\s/, weight: 4 }
            ];

            let newScore = 0;
            let continueScore = 0;

            // Check new requirement indicators
            for (const indicator of newRequirementIndicators) {
                if (indicator.pattern.test(text)) {
                    newScore += indicator.weight;
                    result.keywords.push(indicator.keyword);
                }
            }

            // Check continuation indicators
            for (const indicator of continuationIndicators) {
                if (indicator.pattern.test(text)) {
                    continueScore += indicator.weight;
                }
            }

            // Decision logic
            if (newScore >= 6) {
                result.isNewRequirement = true;
            } else if (continueScore > newScore && currentCondition) {
                result.isContinuation = true;
            } else if (newScore > 0) {
                result.isNewRequirement = true;
            } else if (text.length > 30 && currentCondition) {
                // Longer text without clear indicators - likely continuation
                result.isContinuation = true;
            }

            return result;
        }

        // Create signature for deduplication
        function createConditionSignature(text) {
            // Use first 100 chars normalized
            return text.substring(0, 100)
                .replace(/\s+/g, ' ')
                .replace(/[\d,.]+/g, 'N')
                .trim()
                .toLowerCase();
        }

        // Clean condition text
        function cleanConditionText(text) {
            return text
                .replace(/\[\[PAGE:\d+\]\]/g, '')
                .replace(/\s+/g, ' ')
                .replace(/^[\d\.]+[.\)\-â€“]\s*/, '')
                .replace(/^[×-×ª][.\)\-]\s*/, '')
                .trim();
        }

        // Extract section number from text
        function extractSectionNumber(text) {
            const patterns = [
                /(?:×¡×¢×™×£|×¤×¨×§)\s*(\d+(?:\.\d+)*)/,
                /^(\d+(?:\.\d+)*)[.\)\-]/
            ];

            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) return match[1];
            }
            return null;
        }

        // Deep quantitative data extraction
        function extractQuantitativeDataDeep(text) {
            const result = {
                amount: null,
                count: null,
                years: null,
                turnover: null,
                raw: {}
            };

            // Monetary amounts - multiple patterns
            const amountPatterns = [
                // ×©"×— / â‚ª
                { pattern: /([\d,\.]+)\s*(?:××™×œ×™×•×Ÿ)?\s*(?:â‚ª|×©"×—|×©×§×œ)/i, multiplier: 1 },
                { pattern: /([\d,\.]+)\s*××™×œ×™×•×Ÿ\s*(?:â‚ª|×©"×—|×©×§×œ)?/i, multiplier: 1000000 },
                { pattern: /([\d,\.]+)\s*××œ×£\s*(?:â‚ª|×©"×—|×©×§×œ)?/i, multiplier: 1000 },
                // Turnover specific
                { pattern: /××—×–×•×¨\s*(?:×©× ×ª×™|×›×¡×¤×™)?\s*(?:×©×œ|×‘×¡×š|×œ×¤×—×•×ª)?\s*([\d,\.]+)\s*(?:××™×œ×™×•×Ÿ)?/i, multiplier: 1, isTurnover: true },
                { pattern: /×”×›× ×¡×•×ª\s*(?:×©× ×ª×™×•×ª)?\s*(?:×©×œ|×‘×¡×š|×œ×¤×—×•×ª)?\s*([\d,\.]+)/i, multiplier: 1, isTurnover: true }
            ];

            for (const { pattern, multiplier, isTurnover } of amountPatterns) {
                const match = text.match(pattern);
                if (match) {
                    let value = parseFloat(match[1].replace(/,/g, ''));
                    // Check if "××™×œ×™×•×Ÿ" appears after the number
                    if (text.includes('××™×œ×™×•×Ÿ') && multiplier === 1) {
                        value *= 1000000;
                    }
                    value *= multiplier;

                    if (isTurnover) {
                        result.turnover = value;
                        result.raw.turnover = match[0];
                    } else if (!result.amount) {
                        result.amount = value;
                        result.raw.amount = match[0];
                    }
                }
            }

            // Count patterns - projects, contracts, etc.
            const countPatterns = [
                { pattern: /(\d+)\s*(?:×¤×¨×•×™×§×˜|×¤×¨×•×™×™×§×˜)(?:×™×|×•×ª)?/i, type: 'projects' },
                { pattern: /(\d+)\s*(?:×¢×‘×•×“×•×ª|×¢×‘×•×“×”)/i, type: 'works' },
                { pattern: /(\d+)\s*(?:×—×•×–×™×|×—×•×–×”|×”×¡×›×|×”×¡×›××™×)/i, type: 'contracts' },
                { pattern: /(\d+)\s*(?:×œ×§×•×—×•×ª|×œ×§×•×—)/i, type: 'clients' },
                { pattern: /×œ×¤×—×•×ª\s*(\d+)/i, type: 'minimum' },
                { pattern: /(\d+)\s*(?:×”×ª×§× ×•×ª|××ª×¨×™×|××‘× ×™×)/i, type: 'installations' }
            ];

            for (const { pattern, type } of countPatterns) {
                const match = text.match(pattern);
                if (match && !result.count) {
                    result.count = parseInt(match[1]);
                    result.raw.count = match[0];
                    result.raw.countType = type;
                }
            }

            // Years patterns
            const yearsPatterns = [
                { pattern: /(\d+)\s*×©× ×•×ª?\s*(?:× ×™×¡×™×•×Ÿ|×•×ª×§|×¤×¢×™×œ×•×ª)/i },
                { pattern: /× ×™×¡×™×•×Ÿ\s*(?:×©×œ\s*)?(?:×œ×¤×—×•×ª\s*)?(\d+)\s*×©× /i },
                { pattern: /×•×ª×§\s*(?:×©×œ\s*)?(?:×œ×¤×—×•×ª\s*)?(\d+)\s*×©× /i },
                { pattern: /(?:×‘|-)(\d+)\s*×”×©× ×™×\s*×”××—×¨×•× ×•×ª/i },
                { pattern: /(\d+)\s*×©× ×™×\s*(?:×œ×¤×—×•×ª|×•××¢×œ×”|××—×¨×•× ×•×ª)/i }
            ];

            for (const { pattern } of yearsPatterns) {
                const match = text.match(pattern);
                if (match && !result.years) {
                    result.years = parseInt(match[1]);
                    result.raw.years = match[0];
                }
            }

            return result;
        }

        // Deep requirement type classification
        function classifyRequirementTypeDeep(text) {
            const categories = {
                EXPERIENCE: {
                    patterns: [/× ×™×¡×™×•×Ÿ/, /×‘×™×¦×•×¢/, /×¤×¨×•×™×§×˜/, /×¢×‘×•×“×•×ª/, /×”×ª×§× /, /×™×™×©×•×/],
                    weight: 0
                },
                FINANCIAL: {
                    patterns: [/××—×–×•×¨/, /×”×›× ×¡/, /×”×•×Ÿ/, /×›×¡×¤×™/, /×¤×™× × ×¡/, /×¢×¨×‘×•×ª/, /×‘×™×˜×•×—/],
                    weight: 0
                },
                CERTIFICATION: {
                    patterns: [/×ª×¢×•×“×”/, /×¨×™×©×™×•×Ÿ/, /×”×™×ª×¨/, /×”×¡××›×”/, /ISO/, /×ª×§×Ÿ/, /×¡×™×•×•×’/, /××™×©×•×¨/],
                    weight: 0
                },
                PERSONNEL: {
                    patterns: [/×× ×”×œ/, /×¦×•×•×ª/, /×¢×•×‘×“/, /××”× ×“×¡/, /×™×•×¢×¥/, /×˜×›× ××™/, /×›×•×—.?××“×/],
                    weight: 0
                },
                EQUIPMENT: {
                    patterns: [/×¦×™×•×“/, /××›×•× /, /×¨×›×‘/, /×›×œ×™×/, /××¢×‘×“×”/, /×ª×©×ª×™×ª/],
                    weight: 0
                },
                LEGAL: {
                    patterns: [/××©×¤×˜×™/, /×”×¦×”×¨×”/, /×”×ª×—×™×™×‘×•×ª/, /×—×•×–×”/, /×ª×‘×™×¢/],
                    weight: 0
                },
                QUALITY: {
                    patterns: [/××™×›×•×ª/, /×‘×§×¨×”/, /×ª×§×™× ×”/, /×‘×“×™×§×”/],
                    weight: 0
                }
            };

            for (const [category, data] of Object.entries(categories)) {
                for (const pattern of data.patterns) {
                    if (pattern.test(text)) {
                        data.weight++;
                    }
                }
            }

            // Find highest scoring category
            let maxCategory = 'OTHER';
            let maxWeight = 0;

            for (const [category, data] of Object.entries(categories)) {
                if (data.weight > maxWeight) {
                    maxWeight = data.weight;
                    maxCategory = category;
                }
            }

            return maxCategory;
        }

        // Scan for scattered requirements in full text
        function scanForScatteredRequirements(text, startNumber, tenderId, definitions, extractedSignatures) {
            const conditions = [];
            let conditionNumber = startNumber;

            // Patterns for scattered requirements
            const scatteredPatterns = [
                {
                    pattern: /(?:×¢×œ\s*)?×”××¦×™×¢\s*(?:×—×™×™×‘|× ×“×¨×©|×™×™×“×¨×©)\s*(?:×œ×”×™×•×ª|×œ×”×•×›×™×—|×œ×”×¦×™×’|×œ×¦×¨×£)\s*([^\n.]{20,300})/gi,
                    type: 'MANDATORY'
                },
                {
                    pattern: /(?:×™×©\s*)?×œ×”×¦×™×’\s*(?:××™×©×•×¨|×ª×¢×•×“×”|×¨×™×©×™×•×Ÿ)\s*([^\n.]{10,200})/gi,
                    type: 'MANDATORY'
                },
                {
                    pattern: /×ª× ××™\s*××§×“××™\s*[-â€“:]\s*([^\n]{20,300})/gi,
                    type: 'MANDATORY'
                },
                {
                    pattern: /×“×¨×™×©×•×ª\s*(?:×¡×£|×—×•×‘×”)\s*[-â€“:]?\s*([^\n]{20,300})/gi,
                    type: 'MANDATORY'
                }
            ];

            for (const { pattern, type } of scatteredPatterns) {
                pattern.lastIndex = 0;
                let match;

                while ((match = pattern.exec(text)) !== null) {
                    const conditionText = cleanConditionText(match[1] || match[0]);
                    const signature = createConditionSignature(conditionText);

                    if (conditionText.length >= 20 && !extractedSignatures.has(signature)) {
                        extractedSignatures.add(signature);

                        const quantitative = extractQuantitativeDataDeep(conditionText);
                        const bearer = identifyRequirementBearer(conditionText);

                        conditions.push({
                            tender_id: tenderId,
                            condition_number: String(conditionNumber++),
                            condition_text: conditionText,
                            original_quote: match[0].substring(0, 500),
                            condition_type: type,
                            is_mandatory: type === 'MANDATORY',
                            requirement_type: classifyRequirementTypeDeep(conditionText),
                            required_amount: quantitative.amount,
                            required_count: quantitative.count,
                            required_years: quantitative.years,
                            required_turnover: quantitative.turnover,
                            entity_type: bearer.entity,
                            source_page: extractPageFromPosition(text, match.index),
                            source_section: extractSectionNumber(match[0]),
                            status: 'PENDING'
                        });
                    }
                }
            }

            return conditions;
        }

        // Extract advantage/scoring conditions
        function extractAdvantageConditions(text, startNumber, tenderId, extractedSignatures) {
            const conditions = [];
            let conditionNumber = startNumber;

            const advantagePatterns = [
                { pattern: /×™×ª×¨×•×Ÿ\s*(?:×œ|×™× ×ª×Ÿ\s*×œ|×™×™× ×ª×Ÿ\s*×œ)?\s*(?:××¦×™×¢\s*)?([^\n.]{15,250})/gi },
                { pattern: /×¢×“×™×¤×•×ª\s*(?:×œ|×ª×™× ×ª×Ÿ\s*×œ)?\s*([^\n.]{15,250})/gi },
                { pattern: /× ×™×§×•×“\s*(?:× ×•×¡×£|×¢×•×“×£|××™×›×•×ª)\s*(?:×œ|×¢×‘×•×¨|×™×™× ×ª×Ÿ)?\s*([^\n.]{15,250})/gi },
                { pattern: /(?:×™×§×‘×œ|×™×–×›×”\s*×‘)\s*× ×™×§×•×“\s*(?:× ×•×¡×£|×¢×•×“×£)?\s*([^\n.]{15,250})/gi },
                { pattern: /×§×¨×™×˜×¨×™×•×Ÿ(?:×™×)?\s*(?:××™×›×•×ª|× ×™×§×•×“)\s*[-â€“:]?\s*([^\n.]{15,300})/gi }
            ];

            for (const { pattern } of advantagePatterns) {
                pattern.lastIndex = 0;
                let match;

                while ((match = pattern.exec(text)) !== null) {
                    const conditionText = cleanConditionText(match[1] || match[0]);
                    const signature = createConditionSignature(conditionText);

                    if (conditionText.length >= 15 && !extractedSignatures.has(signature)) {
                        extractedSignatures.add(signature);

                        conditions.push({
                            tender_id: tenderId,
                            condition_number: String(conditionNumber++),
                            condition_text: conditionText,
                            original_quote: match[0].substring(0, 500),
                            condition_type: 'ADVANTAGE',
                            is_mandatory: false,
                            requirement_type: classifyRequirementTypeDeep(conditionText),
                            source_page: extractPageFromPosition(text, match.index),
                            status: 'PENDING'
                        });
                    }
                }
            }

            return conditions;
        }

        // Module 2.2: Extract quantitative requirements
        function extractQuantitativeData(text) {
            const result = { amount: null, count: null, years: null };

            // Extract monetary amount
            const amountMatch = text.match(/([\d,\.]+)\s*(?:â‚ª|×©"×—|××™×œ×™×•×Ÿ|××œ×£)/);
            if (amountMatch) {
                let value = parseFloat(amountMatch[1].replace(/,/g, ''));
                if (text.includes('××™×œ×™×•×Ÿ')) value *= 1000000;
                else if (text.includes('××œ×£')) value *= 1000;
                result.amount = value;
            }

            // Extract count (projects, contracts, etc.)
            const countMatch = text.match(/(\d+)\s*(?:×¤×¨×•×™×§×˜|×¢×‘×•×“×•×ª|×—×•×–×™×|×”×¡×›××™×)/);
            if (countMatch) {
                result.count = parseInt(countMatch[1]);
            }

            // Extract years
            const yearsMatch = text.match(/(\d+)\s*×©× (?:×”|×•×ª|×™×)/);
            if (yearsMatch) {
                result.years = parseInt(yearsMatch[1]);
            }

            return result;
        }

        // Module 2.3: Identify who must meet the requirement
        function identifyRequirementBearer(text) {
            const lowerText = text.toLowerCase();

            if (lowerText.includes('×”××¦×™×¢ ×¢×¦××•') || lowerText.includes('×”××¦×™×¢ ×‘×œ×‘×“')) {
                return { entity: 'BIDDER_ONLY', can_subcontract: false };
            }
            if (lowerText.includes('×§×‘×œ×Ÿ ××©× ×”') || lowerText.includes('×§.××©× ×”')) {
                return { entity: 'SUBCONTRACTOR_ALLOWED', can_subcontract: true };
            }
            if (lowerText.includes('×©×•×ª×£') || lowerText.includes('×§×•× ×¡×•×¨×¦×™×•×')) {
                return { entity: 'PARTNER_ALLOWED', can_subcontract: false };
            }

            // Default - bidder (but might allow subcontractor)
            return { entity: 'BIDDER', can_subcontract: null };
        }

        // Module 2.4: Check for "similar" interpretation
        function checkSimilarityInterpretation(text, definitions) {
            const similarTerms = ['×“×•××”', '×©×•×•×” ×¢×¨×š', '××§×‘×™×œ', '××¡×•×’ ×–×”×”'];

            for (const term of similarTerms) {
                if (text.includes(term)) {
                    // Check if definition exists
                    const def = definitions.find(d => d.term.includes('×“×•××”') || d.term.includes('×©×•×•×”'));
                    return {
                        has_similarity_clause: true,
                        defined_in_tender: !!def,
                        definition: def ? def.definition : null,
                        interpretation: def ? 'DEFINED' : 'OPEN_TO_INTERPRETATION'
                    };
                }
            }
            return { has_similarity_clause: false };
        }

        // Classify requirement type
        function classifyRequirementType(text) {
            if (/× ×™×¡×™×•×Ÿ|×¤×¨×•×™×§×˜|×‘×™×¦×•×¢|×¢×‘×•×“×”|×©× [×”×•×ª]/.test(text)) return 'EXPERIENCE';
            if (/××—×–×•×¨|×”×›× ×¡×•×ª|×”×•×Ÿ|×›×¡×¤×™|×¤×™× × ×¡|×¢×¨×‘×•×ª/.test(text)) return 'FINANCIAL';
            if (/×ª×¢×•×“×”|×¨×™×©×™×•×Ÿ|×”×¡××›×”|ISO|×¡×™×•×•×’|××™×©×•×¨/.test(text)) return 'CERTIFICATION';
            if (/×× ×”×œ|×¦×•×•×ª|×¢×•×‘×“|××”× ×“×¡|×™×•×¢×¥/.test(text)) return 'PERSONNEL';
            if (/×¦×™×•×“|××›×•× ×•×ª|×¨×›×‘|×›×œ×™×/.test(text)) return 'EQUIPMENT';
            return 'OTHER';
        }

        // C1: Find page number (approximate)
        function findPageNumber(fullText, matchText) {
            const position = fullText.indexOf(matchText);
            if (position === -1) return null;
            // Estimate page based on character position (rough: ~3000 chars per page)
            return Math.ceil(position / 3000);
        }

        // C1: Find section number
        function findSectionNumber(fullText, matchText) {
            const position = fullText.indexOf(matchText);
            if (position === -1) return null;

            // Look backwards for section number
            const textBefore = fullText.substring(Math.max(0, position - 500), position);
            const sectionMatch = textBefore.match(/(?:×¡×¢×™×£|×¤×¨×§)\s*(\d+(?:\.\d+)*)/g);
            if (sectionMatch && sectionMatch.length > 0) {
                const lastSection = sectionMatch[sectionMatch.length - 1];
                const numMatch = lastSection.match(/(\d+(?:\.\d+)*)/);
                return numMatch ? numMatch[1] : null;
            }
            return null;
        }

        // ============================================
        // MODULE 2.5: DUAL INTERPRETATION MECHANISM
        // Two "heads" for interpretation when no definitions exist
        // ============================================
        function applyDualInterpretation(conditionText, definitions, category) {
            console.log('[DualInterp] Applying dual interpretation...');

            const result = {
                legal_interpretation: null,
                technical_interpretation: null,
                opening_clauses: [],
                recommendation: null
            };

            // LEGAL HEAD: How would a tender committee interpret this?
            const legalIndicators = {
                strict: ['×‘×“×™×•×§', '×¨×§', '××š ×•×¨×§', '×‘×œ×‘×“', '××“×•×™×§', '×¡×¤×¦×™×¤×™'],
                open: ['××• ×©×•×•×” ×¢×¨×š', '××• ×“×•××”', '×œ×¤×—×•×ª', '××™× ×™××•×', '×›×’×•×Ÿ'],
                proof_dependent: ['×™×•×›×™×—', '×™×¦×™×’', '×™×ª×¢×“', '×œ×”× ×—×ª ×“×¢×ª']
            };

            result.legal_interpretation = {
                classification: 'open', // default
                confidence: 0.5,
                reasoning: ''
            };

            for (const [type, indicators] of Object.entries(legalIndicators)) {
                for (const indicator of indicators) {
                    if (conditionText.includes(indicator)) {
                        result.legal_interpretation.classification = type;
                        result.legal_interpretation.confidence = 0.8;
                        result.legal_interpretation.reasoning = `× ××¦× ××™×œ×” "${indicator}" ×”××¦×‘×™×¢×” ×¢×œ ×¤×¨×©× ×•×ª ${type === 'strict' ? '×§×©×™×—×”' : type === 'open' ? '×¤×ª×•×—×”' : '×ª×œ×•×™×™×ª ×”×•×›×—×”'}`;
                        break;
                    }
                }
            }

            // TECHNICAL HEAD: What technical capabilities are actually needed?
            const technicalDictionary = getTechnicalDictionary(category);
            result.technical_interpretation = {
                required_capabilities: [],
                equivalent_solutions: [],
                reasoning: ''
            };

            // Check for technical terms and find equivalents
            if (technicalDictionary.equivalents) {
                for (const [term, equivalents] of Object.entries(technicalDictionary.equivalents)) {
                    if (conditionText.includes(term)) {
                        result.technical_interpretation.required_capabilities.push(term);
                        result.technical_interpretation.equivalent_solutions = equivalents;
                        result.technical_interpretation.reasoning = `×“×¨×™×©×” ×œ"${term}" ×™×›×•×œ×” ×œ×”×ª××œ× ×’× ×‘×××¦×¢×•×ª: ${equivalents.join(', ')}`;
                    }
                }
            }

            // Detect opening clauses (×¤×ª×—×™×)
            const openingPatterns = [
                { pattern: /× ×™×ª×Ÿ\s*×œ×‘×¦×¢\s*(?:×¤×™×ª×•×—×™×|×”×ª×××•×ª)/i, type: 'development_allowed' },
                { pattern: /× ×™×ª×Ÿ\s*×œ×”×¦×™×¢\s*(?:×¤×ª×¨×•×Ÿ\s*)?×©×•×•×”\s*×¢×¨×š/i, type: 'equivalent_allowed' },
                { pattern: /××•\s*××¢×¨×›×ª\s*×“×•××”/i, type: 'similar_allowed' },
                { pattern: /×œ×¤×™\s*×©×™×§×•×œ\s*×“×¢×ª/i, type: 'discretion' }
            ];

            for (const { pattern, type } of openingPatterns) {
                if (pattern.test(conditionText)) {
                    result.opening_clauses.push({
                        type,
                        found: pattern.exec(conditionText)?.[0]
                    });
                }
            }

            // Generate recommendation
            if (result.legal_interpretation.classification === 'strict') {
                result.recommendation = 'EXACT_MATCH_REQUIRED';
            } else if (result.opening_clauses.length > 0 || result.legal_interpretation.classification === 'open') {
                result.recommendation = 'EQUIVALENT_POSSIBLE';
            } else {
                result.recommendation = 'VERIFY_WITH_CLARIFICATION';
            }

            console.log('[DualInterp] Result:', result);
            return result;
        }

        // ============================================
        // MODULE 2.6: COMPANY PROFILE COMPARISON
        // Match requirements to company profile and identify gaps
        // ============================================
        async function compareToCompanyProfile(tenderId, conditions) {
            console.log('[ProfileCompare] Comparing', conditions.length, 'conditions to company profile...');

            const supabase = getSupabase();
            if (!supabase) return { matches: [], gaps: [], questions: [] };

            // Try to get company profile (if exists)
            let companyProfile = null;
            try {
                const { data: profile } = await supabase
                    .from('company_profiles')
                    .select('*')
                    .limit(1)
                    .single();
                companyProfile = profile;
            } catch (e) {
                console.log('[ProfileCompare] No company profile found');
            }

            // Try to get company projects
            let projects = [];
            try {
                const { data: projectData } = await supabase
                    .from('company_projects')
                    .select('*');
                projects = projectData || [];
            } catch (e) {
                console.log('[ProfileCompare] No projects found');
            }

            const result = {
                matches: [],
                gaps: [],
                questions: [],
                optimization: {
                    for_threshold: [],
                    for_scoring: []
                }
            };

            for (const condition of conditions) {
                const matching = {
                    condition_id: condition.id,
                    condition_text: condition.condition_text,
                    matching_projects: [],
                    matching_certifications: [],
                    status: 'UNKNOWN'
                };

                // Match experience requirements to projects
                if (condition.requirement_type === 'EXPERIENCE') {
                    for (const project of projects) {
                        // Check if project matches requirement
                        const meetsAmount = !condition.required_amount ||
                            (project.total_value >= condition.required_amount);
                        const meetsYears = !condition.required_years ||
                            (project.end_date && new Date(project.end_date) >= new Date(Date.now() - condition.required_years * 365 * 24 * 60 * 60 * 1000));

                        if (meetsAmount && meetsYears) {
                            matching.matching_projects.push({
                                project_id: project.id,
                                project_name: project.name,
                                value: project.total_value,
                                relevance: 'HIGH'
                            });
                        }
                    }

                    if (matching.matching_projects.length >= (condition.required_count || 1)) {
                        matching.status = 'PASS';
                        result.matches.push(matching);
                    } else if (matching.matching_projects.length > 0) {
                        matching.status = 'PARTIAL';
                        result.gaps.push({
                            condition_id: condition.id,
                            gap_type: 'INSUFFICIENT_PROJECTS',
                            have: matching.matching_projects.length,
                            need: condition.required_count || 1,
                            closure_options: ['SUBCONTRACTOR', 'PARTNERSHIP', 'CLARIFICATION']
                        });
                    } else {
                        matching.status = 'FAIL';
                        result.gaps.push({
                            condition_id: condition.id,
                            gap_type: 'NO_MATCHING_PROJECTS',
                            have: 0,
                            need: condition.required_count || 1,
                            closure_options: ['SUBCONTRACTOR', 'PARTNERSHIP']
                        });

                        // Generate question to company
                        result.questions.push({
                            type: 'TO_COMPANY',
                            priority: 'P1',
                            question: `×–×•×”×” ×¤×¢×¨ ×‘×ª× ××™ ×¡×£: "${condition.condition_text}". ×”×× ×§×™×™××™× ×¤×¨×•×™×§×˜×™× ×¨×œ×•×•× ×˜×™×™× ×©×œ× ×”×•×–× ×• ×œ××¢×¨×›×ª?`
                        });
                    }
                }

                // Match certification requirements
                if (condition.requirement_type === 'CERTIFICATION' && companyProfile?.certifications) {
                    const certs = companyProfile.certifications;
                    if (condition.condition_text.includes('ISO') && certs.iso) {
                        matching.matching_certifications.push(certs.iso);
                        matching.status = 'PASS';
                        result.matches.push(matching);
                    }
                }
            }

            // Module 2.6.5: Optimization - threshold vs scoring
            const passedConditions = result.matches.filter(m => m.status === 'PASS');
            result.optimization = {
                for_threshold: passedConditions.slice(0, 3).map(m => m.condition_id),
                for_scoring: passedConditions.slice(3).map(m => m.condition_id),
                strategy: 'MINIMUM_FOR_THRESHOLD_MAX_FOR_SCORING'
            };

            console.log('[ProfileCompare] Result - Matches:', result.matches.length, 'Gaps:', result.gaps.length);
            return result;
        }

        // ============================================
        // MODULE 2.7: CLARIFICATION REQUESTS GENERATION
        // Generate requests to issuer and questions to company
        // ============================================
        function generateClarificationRequests(conditions, gaps, definitions) {
            console.log('[Clarifications] Generating clarification requests...');

            const requests = {
                to_issuer: [],
                to_company: [],
                strategic: []
            };

            // Analyze each gap and generate appropriate request
            for (const gap of gaps) {
                const condition = conditions.find(c => c.id === gap.condition_id);
                if (!condition) continue;

                // Generate issuer request based on gap type
                if (gap.closure_options.includes('CLARIFICATION')) {
                    const issuerRequest = {
                        priority: determinePriority(gap, condition),
                        request_text: '',
                        purpose: '',
                        condition_ref: condition.condition_number
                    };

                    // Request format: polite request to expand interpretation
                    if (gap.gap_type === 'INSUFFICIENT_PROJECTS') {
                        issuerRequest.request_text = `× ×‘×§×© ×œ×—×“×“ ××ª ×ª× ××™ ×¡×£ ${condition.condition_number}: ×”×× × ×™×ª×Ÿ ×œ×”×¡×ª××š ×¢×œ × ×™×¡×™×•×Ÿ ×§×‘×œ×Ÿ ××©× ×” ×œ×¦×•×¨×š ×”×•×›×—×ª × ×™×¡×™×•×Ÿ ×‘×ª×—×•× ${condition.condition_text.substring(0, 50)}...?`;
                        issuerRequest.purpose = 'EXPAND_ELIGIBILITY';
                    } else if (gap.gap_type === 'NO_MATCHING_PROJECTS') {
                        issuerRequest.request_text = `× ×‘×§×© ×”×‘×”×¨×” ×‘× ×•×’×¢ ×œ×ª× ××™ ×¡×£ ${condition.condition_number}: ×”×× ×¤×¨×•×™×§×˜ ×‘×ª×—×•× ×“×•××” (${condition.condition_text.substring(0, 30)}...) ×™×¢× ×” ×¢×œ ×”×“×¨×™×©×”?`;
                        issuerRequest.purpose = 'EXPAND_DEFINITION';
                    }

                    requests.to_issuer.push(issuerRequest);
                }

                // Generate company questions
                if (gap.gap_type.includes('PROJECT')) {
                    requests.to_company.push({
                        priority: 'P1',
                        question: `×‘× ×•×’×¢ ×œ×“×¨×™×©×” "${condition.condition_text.substring(0, 50)}..." - ×”×× ×™×© ×¤×¨×•×™×§×˜×™× × ×•×¡×¤×™× ×©×œ× ×”×•×–× ×• ×œ××¢×¨×›×ª?`,
                        purpose: 'COMPLETE_PROFILE'
                    });
                }
            }

            // Check for undefined terms that need clarification
            const undefinedTerms = ['×¤×¨×•×™×§×˜ ×“×•××”', '× ×™×¡×™×•×Ÿ ××•×›×—', '×”×™×§×£ ×“×•××”', '××¢×¨×›×ª ××§×‘×™×œ×”'];
            for (const term of undefinedTerms) {
                const conditionsWithTerm = conditions.filter(c => c.condition_text.includes(term));
                const termDefined = definitions.some(d => d.term.includes(term));

                if (conditionsWithTerm.length > 0 && !termDefined) {
                    requests.to_issuer.push({
                        priority: 'P2',
                        request_text: `× ×‘×§×© ×œ×”×’×“×™×¨ ××ª ×”××•× ×— "${term}" ×”××•×¤×™×¢ ×‘×ª× ××™ ×”×¡×£ - ××”× ×”×§×¨×™×˜×¨×™×•× ×™× ×”××“×•×™×§×™×?`,
                        purpose: 'DEFINE_TERM',
                        condition_refs: conditionsWithTerm.map(c => c.condition_number)
                    });
                }
            }

            console.log('[Clarifications] Generated - To issuer:', requests.to_issuer.length, 'To company:', requests.to_company.length);
            return requests;
        }

        function determinePriority(gap, condition) {
            if (condition.is_mandatory && gap.gap_type === 'NO_MATCHING_PROJECTS') return 'P1';
            if (condition.is_mandatory) return 'P2';
            return 'P3';
        }

        // ============================================
        // MODULE 2.7.5: STRATEGIC QUESTIONS FOR COMPETITOR EXCLUSION
        // Questions designed to reduce competition (without hurting us)
        // ============================================
        function generateStrategicQuestions(conditions, companyProfile, category) {
            console.log('[Strategic] Generating strategic questions...');

            const strategicQuestions = [];
            const technicalDictionary = getTechnicalDictionary(category);

            // Identify our exclusive advantages
            const ourAdvantages = {
                exclusive_representations: [], // Products we exclusively represent
                unique_certifications: [],
                unique_capabilities: []
            };

            // Check for opportunities to tighten requirements in our favor
            const opportunities = [
                {
                    type: 'NDAA_COMPLIANCE',
                    check: (text) => text.includes('××¦×œ×') && !text.includes('NDAA'),
                    question: '× ×‘×§×© ×œ×”×‘×”×™×¨ ×”×× × ×“×¨×©×ª ×¢××™×“×” ×‘×ª×§×Ÿ NDAA ×¢×‘×•×¨ ×¦×™×•×“ ×”××¦×œ××•×ª, ×œ××•×¨ ×“×¨×™×©×•×ª ××‘×˜×—×ª ××™×“×¢?',
                    justification: '×”×’× ×” ××ª×§×™×¤×•×ª ×¡×™×™×‘×¨ ×•×¦×™×•×ª ×œ×“×¨×™×©×•×ª ×‘×™×˜×—×•× ×™×•×ª',
                    benefits_us: true
                },
                {
                    type: 'SPECIFIC_RESOLUTION',
                    check: (text) => text.includes('××¦×œ×') && !text.match(/\d+MP/),
                    question: '× ×‘×§×© ×œ×—×“×“ ××ª ×“×¨×™×©×•×ª ×”×¨×–×•×œ×•×¦×™×” ×”××™× ×™××œ×™×ª ×¢×‘×•×¨ ×”××¦×œ××•×ª - ×”×× × ×“×¨×© 4MP ×•××¢×œ×”?',
                    justification: '×¨×–×•×œ×•×¦×™×” ×’×‘×•×”×” ×™×•×ª×¨ ×œ×¦×¨×›×™ ×–×™×”×•×™ ×•×× ×œ×™×˜×™×§×”',
                    benefits_us: true
                },
                {
                    type: 'CYBER_CERTIFICATION',
                    check: (text) => (text.includes('×¨×©×ª') || text.includes('×ª×§×©×•×¨×ª')) && !text.includes('×¡×™×™×‘×¨'),
                    question: '× ×‘×§×© ×œ×”×‘×”×™×¨ ×”×× × ×“×¨×©×ª ×”×¡××›×ª ×¡×™×™×‘×¨ (ISO 27001) ××”××¦×™×¢?',
                    justification: '×”×’× ×” ××¤× ×™ ××™×•××™ ×¡×™×™×‘×¨ ×¢×œ ×ª×©×ª×™×•×ª ×§×¨×™×˜×™×•×ª',
                    benefits_us: true
                }
            ];

            for (const opp of opportunities) {
                for (const condition of conditions) {
                    if (opp.check(condition.condition_text)) {
                        // Verify this doesn't hurt us before suggesting
                        if (opp.benefits_us) {
                            strategicQuestions.push({
                                type: opp.type,
                                question: opp.question,
                                justification: opp.justification,
                                target_condition: condition.condition_number,
                                potential_impact: 'MAY_EXCLUDE_COMPETITORS',
                                self_check: 'VERIFIED_SAFE'
                            });
                        }
                    }
                }
            }

            console.log('[Strategic] Generated', strategicQuestions.length, 'strategic questions');
            return strategicQuestions;
        }

        // ============================================
        // MODULE 2.8: REQUIRED DOCUMENTS LIST
        // For each requirement - what documents need to be attached
        // ============================================
        function generateRequiredDocumentsList(conditions) {
            console.log('[RequiredDocs] Generating required documents list...');

            const documentsList = [];

            const documentMappings = {
                EXPERIENCE: [
                    { type: '××™×©×•×¨ ××–××™×Ÿ', format: '××§×•×¨/×”×¢×ª×§ × ×××Ÿ', signer: '× ×¦×™×’ ××–××™×Ÿ' },
                    { type: '×—×•×–×” ×”×ª×§×©×¨×•×ª', format: '×”×¢×ª×§', signer: '×œ× × ×“×¨×©' },
                    { type: '×—×©×‘×•× ×™×ª ×¡×•×¤×™×ª', format: '×”×¢×ª×§', signer: '×œ× × ×“×¨×©' }
                ],
                FINANCIAL: [
                    { type: '××™×©×•×¨ ×¨×•××” ×—×©×‘×•×Ÿ', format: '××§×•×¨', signer: '×¨×•"×—' },
                    { type: '×“×•×—×•×ª ×›×¡×¤×™×™×', format: '××‘×•×§×¨×™×', signer: '×¨×•"×—' },
                    { type: '××™×©×•×¨ × ×™×”×•×œ ×¡×¤×¨×™×', format: '××§×•×¨', signer: '××¡ ×”×›× ×¡×”' }
                ],
                CERTIFICATION: [
                    { type: '×ª×¢×•×“×ª ISO', format: '×”×¢×ª×§ × ×××Ÿ', signer: '×’×•×£ ××¡××™×š' },
                    { type: '×¨×™×©×™×•×Ÿ ×§×‘×œ×Ÿ', format: '×”×¢×ª×§', signer: '×¨×©× ×”×§×‘×œ× ×™×' }
                ],
                PERSONNEL: [
                    { type: '×§×•×¨×•×ª ×—×™×™×', format: '××§×•×¨', signer: '×”×¢×•×‘×“' },
                    { type: '×ª×¢×•×“×•×ª ×”×©×›×œ×”', format: '×”×¢×ª×§ × ×××Ÿ', signer: '××•×¡×“ ×œ×™××•×“×™×' },
                    { type: '××™×©×•×¨ ×”×¢×¡×§×”', format: '××§×•×¨', signer: '××¢×¡×™×§' }
                ]
            };

            for (const condition of conditions) {
                const docs = documentMappings[condition.requirement_type] || [];

                for (const doc of docs) {
                    documentsList.push({
                        condition_id: condition.id,
                        condition_number: condition.condition_number,
                        condition_text: condition.condition_text.substring(0, 50) + '...',
                        document_type: doc.type,
                        required_format: doc.format,
                        signer: doc.signer,
                        status: 'MISSING', // Will be updated when documents are attached
                        validity_check: null
                    });
                }
            }

            console.log('[RequiredDocs] Generated', documentsList.length, 'document requirements');
            return documentsList;
        }

        // ============================================
        // MODULE 2.9: ASSESSMENT AND RECOMMENDATION
        // Summary report for each requirement with full traceability
        // ============================================
        function generateRequirementAssessment(condition, companyMatch, interpretation) {
            console.log('[Assessment] Generating assessment for condition:', condition.condition_number);

            const assessment = {
                condition_number: condition.condition_number,
                // 1. What the requirement says + exact quote
                requirement_statement: {
                    text: condition.condition_text,
                    source: {
                        page: condition.source_page,
                        section: condition.source_section
                    }
                },
                // 2. Legal meaning
                legal_meaning: {
                    classification: interpretation?.legal_interpretation?.classification || 'UNKNOWN',
                    explanation: interpretation?.legal_interpretation?.reasoning || '×œ× × ×•×ª×—'
                },
                // 3. Technical meaning
                technical_meaning: {
                    required_capabilities: interpretation?.technical_interpretation?.required_capabilities || [],
                    equivalents: interpretation?.technical_interpretation?.equivalent_solutions || []
                },
                // 4. Company profile support
                profile_support: {
                    matching_evidence: companyMatch?.matching_projects || [],
                    missing: companyMatch?.status === 'FAIL' ? '××™×Ÿ ×”×ª×××” ×‘×¤×¨×•×¤×™×œ' : null
                },
                // 5. Possible arguments and closure paths
                closure_paths: [],
                // 6. Conclusion
                conclusion: {
                    status: 'UNKNOWN',
                    confidence: 0,
                    recommendation: ''
                }
            };

            // Determine conclusion based on all factors
            if (companyMatch?.status === 'PASS') {
                assessment.conclusion = {
                    status: 'PASS',
                    confidence: 0.9,
                    recommendation: '×¢×•××“ ×‘×•×•×“××•×ª'
                };
            } else if (companyMatch?.status === 'PARTIAL') {
                assessment.conclusion = {
                    status: 'RISK',
                    confidence: 0.6,
                    recommendation: '×¢×•××“ + ×¡×™×›×•×Ÿ - ××•××œ×¥ ×œ×©×§×•×œ ×§×‘×œ×Ÿ ××©× ×” ××• ×©××œ×ª ×”×‘×”×¨×”'
                };
                assessment.closure_paths = ['SUBCONTRACTOR', 'CLARIFICATION'];
            } else if (interpretation?.opening_clauses?.length > 0) {
                assessment.conclusion = {
                    status: 'PENDING',
                    confidence: 0.5,
                    recommendation: '×‘×›×¤×•×£ ×œ××™××•×ª - ×–×•×”×• ×¤×ª×—×™× ×‘× ×™×¡×•×—'
                };
                assessment.closure_paths = ['CLARIFICATION', 'ALTERNATIVE_DOC'];
            } else {
                assessment.conclusion = {
                    status: 'FAIL',
                    confidence: 0.8,
                    recommendation: '×œ× ×¢×•××“ - × ×“×¨×© ×¤×ª×¨×•×Ÿ'
                };
                assessment.closure_paths = ['SUBCONTRACTOR', 'PARTNERSHIP', 'BLOCKER'];
            }

            return assessment;
        }

        // ============================================
        // MODULE 2.10: RE-ANALYSIS AFTER CLARIFICATIONS
        // Run analysis again after clarification responses received
        // ============================================
        async function reAnalyzeAfterClarifications(tenderId, previousAnalysis) {
            console.log('[ReAnalyze] Re-analyzing tender after clarifications:', tenderId);

            const supabase = getSupabase();
            if (!supabase) return null;

            // Get the latest clarification document
            const { data: docs } = await supabase
                .from('tender_documents')
                .select('*')
                .eq('tender_id', tenderId)
                .eq('document_type', 'CLARIFICATIONS')
                .order('created_at', { ascending: false })
                .limit(1);

            if (!docs || docs.length === 0) {
                console.log('[ReAnalyze] No clarification documents found');
                return { changed: false, message: '×œ× × ××¦××• ××¡××›×™ ×”×‘×”×¨×•×ª' };
            }

            const changeReport = {
                tender_id: tenderId,
                analysis_date: new Date().toISOString(),
                changes_detected: [],
                impact_on_bidder: [],
                go_nogo_changed: false,
                previous_recommendation: previousAnalysis?.recommendation || 'UNKNOWN',
                new_recommendation: 'UNKNOWN'
            };

            // Compare current state to previous
            // This would need to re-run the full analysis and compare

            // For now, mark that re-analysis was triggered
            await supabase
                .from('tenders')
                .update({
                    current_step: 'RE_ANALYZED',
                    last_analysis_date: new Date().toISOString()
                })
                .eq('id', tenderId);

            console.log('[ReAnalyze] Re-analysis complete');
            return changeReport;
        }

        // ============================================
        // PILLAR 3: SPECIFICATION & BOQ ANALYSIS
        // ============================================

        // Module 3.1: Technical Specification Analysis
        function analyzeSpecification(text) {
            console.log('[Spec] Analyzing technical specification...');

            const specification = {
                general_requirements: [],
                technical_requirements: [],
                execution_requirements: [],
                sla_requirements: [],
                standards: []
            };

            // Extract general requirements
            const generalPatterns = [
                /×“×¨×™×©×•×ª\s*×›×œ×œ×™×•×ª[:\s]*([^\n]+)/gi,
                /×ª×§×Ÿ\s*([^\n]+)/gi,
                /×¢××™×“×”\s*×‘[-]?\s*([^\n]+)/gi
            ];

            for (const pattern of generalPatterns) {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    specification.general_requirements.push({
                        text: match[1].trim(),
                        source_position: match.index
                    });
                }
            }

            // Extract SLA requirements
            const slaPatterns = [
                /SLA[:\s]*([^\n]+)/gi,
                /×¨××ª\s*×©×™×¨×•×ª[:\s]*([^\n]+)/gi,
                /×–××Ÿ\s*×ª×’×•×‘×”[:\s]*(\d+)\s*(?:×©×¢×•×ª|×“×§×•×ª)/gi,
                /×–××Ÿ\s*×ª×™×§×•×Ÿ[:\s]*(\d+)\s*(?:×©×¢×•×ª|×™××™×)/gi
            ];

            for (const pattern of slaPatterns) {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    specification.sla_requirements.push({
                        text: match[0].trim(),
                        value: match[1],
                        source_position: match.index
                    });
                }
            }

            // Extract standards
            const standardsPatterns = [
                /ISO\s*(\d+)/gi,
                /×ª×§×Ÿ\s*×™×©×¨××œ×™\s*(\d+)/gi,
                /×ª"×™\s*(\d+)/gi
            ];

            for (const pattern of standardsPatterns) {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    specification.standards.push({
                        standard: match[0].trim(),
                        number: match[1]
                    });
                }
            }

            console.log('[Spec] Found requirements - General:', specification.general_requirements.length,
                'SLA:', specification.sla_requirements.length, 'Standards:', specification.standards.length);
            return specification;
        }

        // Module 3.2: Bill of Quantities (BOQ) Analysis
        function analyzeBOQ(text) {
            console.log('[BOQ] Analyzing bill of quantities...');

            const boq = {
                items: [],
                categories: {},
                totals: {
                    supply: 0,
                    work: 0,
                    service: 0,
                    maintenance: 0
                }
            };

            // BOQ line pattern: number, description, unit, quantity, price
            const boqPatterns = [
                /(\d+(?:\.\d+)?)\s+([^\t\n]{10,100})\s+(×™×—'|×'|×"×¨|×©×¢×•×ª|×—×•×“×©|×¤××•×©×œ×™)\s+(\d+(?:,\d+)?(?:\.\d+)?)/gi,
                /×¤×¨×™×˜\s*(\d+)[:\s]*([^\n]{10,100})/gi
            ];

            for (const pattern of boqPatterns) {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const item = {
                        line_id: match[1],
                        description: match[2].trim(),
                        unit: match[3] || '×™×—\'',
                        quantity: parseFloat((match[4] || '1').replace(/,/g, '')),
                        category: categorizeBOQItem(match[2]),
                        completeness: 'COMPLETE'
                    };

                    boq.items.push(item);

                    // Aggregate by category
                    if (!boq.categories[item.category]) {
                        boq.categories[item.category] = [];
                    }
                    boq.categories[item.category].push(item);
                }
            }

            console.log('[BOQ] Found', boq.items.length, 'BOQ items');
            return boq;
        }

        function categorizeBOQItem(description) {
            const lower = description.toLowerCase();
            if (/××¡×¤×§×”|×¦×™×•×“|××¦×œ××”|××ª×’|×©×¨×ª/.test(lower)) return 'supply';
            if (/×”×ª×§× ×”|×¢×‘×•×“×”|×—×¤×™×¨×”|×›×‘×™×œ×”/.test(lower)) return 'work';
            if (/×©×™×¨×•×ª|×ª××™×›×”|×”×“×¨×›×”/.test(lower)) return 'service';
            if (/×ª×—×–×•×§×”|××—×–×§×”/.test(lower)) return 'maintenance';
            return 'other';
        }

        // Module 3.3: Work Scope Understanding
        function analyzeWorkScope(specification, boq) {
            console.log('[WorkScope] Analyzing work scope...');

            const workScope = {
                phases: {
                    planning: { items: [], estimated_scope: 0 },
                    supply: { items: [], estimated_scope: 0 },
                    installation: { items: [], estimated_scope: 0 },
                    commissioning: { items: [], estimated_scope: 0 },
                    maintenance: { items: [], estimated_scope: 0 }
                },
                hidden_work_indicators: [],
                warnings: []
            };

            // Categorize BOQ items into phases
            for (const item of boq.items) {
                if (item.category === 'supply') {
                    workScope.phases.supply.items.push(item);
                } else if (item.category === 'work') {
                    workScope.phases.installation.items.push(item);
                } else if (item.category === 'maintenance') {
                    workScope.phases.maintenance.items.push(item);
                }
            }

            // Detect hidden work indicators
            const hiddenWorkPatterns = [
                '×›×œ ×”×¢×‘×•×“×•×ª ×”× ×“×¨×©×•×ª ×œ×”×©×œ××”',
                '×›×•×œ×œ ×›×œ ×”× ×œ×•×•×™×',
                '×œ×¤×™ ×”× ×—×™×•×ª ×”××¤×§×—',
                '×œ×©×‘×™×¢×•×ª ×¨×¦×•×Ÿ ×”××–××™×Ÿ'
            ];

            for (const pattern of hiddenWorkPatterns) {
                const found = boq.items.filter(i => i.description.includes(pattern));
                if (found.length > 0) {
                    workScope.hidden_work_indicators.push({
                        pattern,
                        items: found,
                        risk: 'HIGH'
                    });
                    workScope.warnings.push(`×–×•×”×” × ×™×¡×•×— ×’×•×¨×£: "${pattern}" - ×¡×™×›×•×Ÿ ×œ×¢×‘×•×“×•×ª × ×¡×ª×¨×•×ª`);
                }
            }

            console.log('[WorkScope] Phases analyzed, hidden indicators:', workScope.hidden_work_indicators.length);
            return workScope;
        }

        // Module 3.4: Discrepancy Detection
        function detectDiscrepancies(specification, boq) {
            console.log('[Discrepancy] Detecting discrepancies...');

            const discrepancies = {
                spec_vs_boq: [],
                in_spec_not_boq: [],
                in_boq_not_spec: [],
                internal_contradictions: []
            };

            // Check for items in spec but not in BOQ (HIGH RISK)
            const specItems = specification.technical_requirements.map(r => r.text);
            const boqDescriptions = boq.items.map(i => i.description);

            // Simple keyword matching
            const specKeywords = ['××¦×œ××•×ª', '××ª×’', '×©×¨×ª', '×›×‘×™×œ×”', '×¢××•×“×™×', '×—×¤×™×¨×”'];

            for (const keyword of specKeywords) {
                const inSpec = specItems.some(s => s.includes(keyword));
                const inBOQ = boqDescriptions.some(d => d.includes(keyword));

                if (inSpec && !inBOQ) {
                    discrepancies.in_spec_not_boq.push({
                        item: keyword,
                        risk: 'HIGH',
                        reason: '× ×“×¨×© ×œ×ª××—×•×¨ ××‘×œ ×œ× ××§×‘×œ×™× ×›×¡×£',
                        recommendation: '×œ×”×¢×œ×•×ª ×›×©××œ×ª ×”×‘×”×¨×” ××• ×œ×ª××—×¨ ×‘×¢×œ×•×™×•×ª ××—×¨×•×ª'
                    });
                }

                if (inBOQ && !inSpec) {
                    discrepancies.in_boq_not_spec.push({
                        item: keyword,
                        risk: 'MEDIUM',
                        reason: '××•×¤×™×¢ ×‘-BOQ ××š ×œ× ×‘××¤×¨×˜ - ×œ×•×•×“× ×“×¨×™×©×•×ª'
                    });
                }
            }

            console.log('[Discrepancy] Found - Spec not BOQ:', discrepancies.in_spec_not_boq.length,
                'BOQ not Spec:', discrepancies.in_boq_not_spec.length);
            return discrepancies;
        }

        // Module 3.5: Pricing Risk Analysis
        function analyzePricingRisks(boq, discrepancies, workScope) {
            console.log('[PricingRisk] Analyzing pricing risks...');

            const pricingAnalysis = {
                risk_items: [],
                recommendations: {
                    reserve_percentage: 0,
                    detailed_pricing: [],
                    lump_sum: []
                },
                smart_pricing: {
                    opportunities: [],
                    warnings: []
                }
            };

            // Identify high-risk items
            for (const item of boq.items) {
                let riskLevel = 'LOW';
                let reasons = [];

                // Check for risky keywords
                if (/×›×œ ×”× ×“×¨×©|×œ×¤×™ ×”×¦×•×¨×š|×œ×©×‘×™×¢×•×ª ×¨×¦×•×Ÿ/.test(item.description)) {
                    riskLevel = 'HIGH';
                    reasons.push('× ×™×¡×•×— ×’×•×¨×£');
                }

                if (/×¤××•×©×œ×™/.test(item.unit)) {
                    riskLevel = Math.max(riskLevel, 'MEDIUM');
                    reasons.push('×ª××—×•×¨ ×¤××•×©×œ×™');
                }

                if (riskLevel !== 'LOW') {
                    pricingAnalysis.risk_items.push({
                        item_id: item.line_id,
                        description: item.description,
                        risk_level: riskLevel,
                        reasons
                    });
                }
            }

            // Calculate reserve recommendation
            const highRiskCount = pricingAnalysis.risk_items.filter(r => r.risk_level === 'HIGH').length;
            const mediumRiskCount = pricingAnalysis.risk_items.filter(r => r.risk_level === 'MEDIUM').length;

            pricingAnalysis.recommendations.reserve_percentage =
                (highRiskCount * 5) + (mediumRiskCount * 2) +
                (discrepancies.in_spec_not_boq.length * 3) +
                (workScope.hidden_work_indicators.length * 4);

            // Identify pricing opportunities from discrepancies (×¢×™×“×•'s insight)
            for (const disc of discrepancies.in_spec_not_boq) {
                pricingAnalysis.smart_pricing.opportunities.push({
                    type: 'EXPECTED_EXTRA',
                    description: disc.item,
                    recommendation: '×œ×ª×ª ×”× ×—×” ×¢×œ ×©×•×¨×•×ª BOQ ×•×œ×”×¨×•×•×™×— ××—×¨×™×’×™×'
                });
            }

            console.log('[PricingRisk] Risk items:', pricingAnalysis.risk_items.length,
                'Reserve:', pricingAnalysis.recommendations.reserve_percentage + '%');
            return pricingAnalysis;
        }

        // ============================================
        // PILLAR 4: COMPETITOR ANALYSIS
        // ============================================

        // Module 4.1: Winning Bids Collection (stub - needs external data)
        async function collectWinningBids(tenderId, category) {
            console.log('[Competitors] Collecting winning bids data...');

            // This would typically fetch from external sources like mr.gov.il
            // For now, return structure for future implementation
            return {
                source: 'mr.gov.il',
                tenders_analyzed: 0,
                winning_bids: [],
                message: '× ×“×¨×© ×—×™×‘×•×¨ ×œ××§×•×¨×•×ª ××™×“×¢ ×—×™×¦×•× ×™×™×'
            };
        }

        // Module 4.2: Competitor Mapping
        async function mapCompetitors(tenderId, category) {
            console.log('[Competitors] Mapping competitors...');

            const supabase = getSupabase();

            // Try to get competitors from database
            let competitors = [];
            if (supabase) {
                try {
                    const { data } = await supabase
                        .from('competitors')
                        .select('*')
                        .limit(20);
                    competitors = data || [];
                } catch (e) {
                    console.log('[Competitors] No competitor data');
                }
            }

            const mapping = {
                competitors: competitors.map(c => ({
                    name: c.name,
                    size: c.size || 'UNKNOWN',
                    specialization: c.specialization_areas || [],
                    pricing_strategy: c.pricing_strategy || 'unknown',
                    strengths: c.known_strengths || [],
                    weaknesses: c.known_weaknesses || []
                })),
                win_loss_history: []
            };

            console.log('[Competitors] Mapped', mapping.competitors.length, 'competitors');
            return mapping;
        }

        // Module 4.3: Competitor Pricing Analysis
        function analyzeCompetitorPricing(winningBids, boq) {
            console.log('[Competitors] Analyzing competitor pricing...');

            const analysis = {
                per_item: {},
                patterns: [],
                insights: []
            };

            // If we have winning bids data, analyze it
            if (winningBids.winning_bids && winningBids.winning_bids.length > 0) {
                // Calculate average prices per item
                for (const bid of winningBids.winning_bids) {
                    for (const item of bid.items || []) {
                        if (!analysis.per_item[item.description]) {
                            analysis.per_item[item.description] = {
                                prices: [],
                                average: 0,
                                min: Infinity,
                                max: 0
                            };
                        }
                        analysis.per_item[item.description].prices.push(item.price);
                    }
                }

                // Calculate statistics
                for (const [desc, data] of Object.entries(analysis.per_item)) {
                    data.average = data.prices.reduce((a, b) => a + b, 0) / data.prices.length;
                    data.min = Math.min(...data.prices);
                    data.max = Math.max(...data.prices);
                }
            }

            return analysis;
        }

        // Module 4.4: Competitive Intelligence
        function generateCompetitiveIntelligence(competitors, conditions, companyProfile) {
            console.log('[Competitors] Generating competitive intelligence...');

            const intelligence = {
                participation_forecast: [],
                differentiation: {
                    our_advantages: [],
                    our_disadvantages: []
                },
                expected_price_range: { min: 0, max: 0 },
                strategic_recommendations: []
            };

            // Forecast participation based on condition match
            for (const competitor of competitors.competitors) {
                const probability = estimateParticipationProbability(competitor, conditions);
                intelligence.participation_forecast.push({
                    competitor: competitor.name,
                    probability,
                    reason: probability > 0.5 ? '××ª××™× ×œ×ª× ××™ ×”×¡×£' : '×¢×œ×•×œ ×œ×”×™×•×ª ××•×’×‘×œ ×‘×ª× ××™ ×¡×£'
                });
            }

            // Identify our differentiation
            if (companyProfile) {
                // Our advantages
                if (companyProfile.certifications?.iso) {
                    intelligence.differentiation.our_advantages.push('×”×¡××›×•×ª ISO');
                }
                if (companyProfile.projects?.length > 5) {
                    intelligence.differentiation.our_advantages.push('× ×™×¡×™×•×Ÿ ×¢×©×™×¨ ×‘×¤×¨×•×™×§×˜×™×');
                }
            }

            console.log('[Competitors] Generated forecast for', intelligence.participation_forecast.length, 'competitors');
            return intelligence;
        }

        function estimateParticipationProbability(competitor, conditions) {
            // Simple probability based on specialization match
            let matchScore = 0;
            const specializations = competitor.specialization || [];

            for (const condition of conditions) {
                if (condition.requirement_type === 'EXPERIENCE') {
                    for (const spec of specializations) {
                        if (condition.condition_text.toLowerCase().includes(spec.toLowerCase())) {
                            matchScore += 1;
                        }
                    }
                }
            }

            return Math.min(matchScore / conditions.length, 1);
        }

        // ============================================
        // OUTPUT: DECISION REPORT (GO/NO-GO)
        // ============================================
        async function generateDecisionReport(tenderId) {
            console.log('[Decision] Generating GO/NO-GO decision report...');

            const supabase = getSupabase();
            if (!supabase) return null;

            // Fetch all tender data
            const { data: tender } = await supabase
                .from('tenders')
                .select('*')
                .eq('id', tenderId)
                .single();

            const { data: conditions } = await supabase
                .from('gate_conditions')
                .select('*')
                .eq('tender_id', tenderId);

            // Calculate overall assessment
            const passedConditions = conditions?.filter(c => c.status === 'PASS') || [];
            const failedConditions = conditions?.filter(c => c.status === 'FAIL') || [];
            const riskConditions = conditions?.filter(c => c.status === 'RISK') || [];
            const totalMandatory = conditions?.filter(c => c.is_mandatory) || [];

            // Decision logic
            let recommendation = 'CONDITIONAL';
            let confidence = 0.5;
            let riskLevel = 'MEDIUM';

            if (failedConditions.length > 0 && failedConditions.some(c => c.is_mandatory)) {
                recommendation = 'NO_GO';
                confidence = 0.8;
                riskLevel = 'HIGH';
            } else if (passedConditions.length === totalMandatory.length) {
                recommendation = 'GO';
                confidence = 0.85;
                riskLevel = 'LOW';
            } else if (riskConditions.length > 0) {
                recommendation = 'CONDITIONAL';
                confidence = 0.6;
                riskLevel = 'MEDIUM';
            }

            const report = {
                // Executive Summary
                executive_summary: {
                    recommendation,
                    confidence_level: Math.round(confidence * 100),
                    overall_risk_level: riskLevel,
                    estimated_win_probability: calculateWinProbability(conditions, recommendation),
                    one_sentence_summary: generateSummary(recommendation, tender, conditions)
                },

                // Requirements Summary
                requirements_summary: {
                    total: conditions?.length || 0,
                    passed: passedConditions.length,
                    failed: failedConditions.length,
                    risk: riskConditions.length,
                    gaps_to_close: failedConditions.map(c => ({
                        priority: c.is_mandatory ? 'P1' : 'P2',
                        description: c.condition_text
                    }))
                },

                // Action Items
                action_items: {
                    before_decision: [],
                    if_go: {
                        send_clarifications: tender?.clarification_deadline,
                        submission_deadline: tender?.submission_deadline
                    }
                },

                // Metadata
                generated_at: new Date().toISOString(),
                tender_id: tenderId
            };

            // Save report to database
            try {
                await supabase
                    .from('decision_reports')
                    .upsert({
                        tender_id: tenderId,
                        report_data: report,
                        recommendation,
                        confidence_level: Math.round(confidence * 100),
                        created_at: new Date().toISOString()
                    });
            } catch (e) {
                console.log('[Decision] Could not save report:', e.message);
            }

            console.log('[Decision] Report generated:', recommendation, 'with', Math.round(confidence * 100) + '% confidence');
            return report;
        }

        function calculateWinProbability(conditions, recommendation) {
            if (recommendation === 'NO_GO') return 0;
            if (recommendation === 'GO') return 65;
            return 40; // CONDITIONAL
        }

        function generateSummary(recommendation, tender, conditions) {
            const name = tender?.tender_name || '×”××›×¨×–';
            const passRate = conditions?.length > 0
                ? Math.round((conditions.filter(c => c.status === 'PASS').length / conditions.length) * 100)
                : 0;

            if (recommendation === 'GO') {
                return `${name} - ××•××œ×¥ ×œ×”×’×™×©. ×¢×•××“×™× ×‘-${passRate}% ××ª× ××™ ×”×¡×£.`;
            } else if (recommendation === 'NO_GO') {
                return `${name} - ×œ× ××•××œ×¥ ×œ×”×’×™×©. ×¤×¢×¨×™× ××©××¢×•×ª×™×™× ×‘×ª× ××™ ×”×¡×£.`;
            }
            return `${name} - ×”×—×œ×˜×” ××•×ª× ×™×ª. × ×“×¨×©×•×ª ×¤×¢×•×œ×•×ª ×œ×¡×’×™×¨×ª ×¤×¢×¨×™×.`;
        }

        // ============================================
        // FULL ANALYSIS PIPELINE
        // Run all analysis modules in sequence
        // ============================================
        async function runFullAnalysis(tenderId, text, fileName) {
            console.log('[FullAnalysis] Starting full analysis pipeline for tender:', tenderId);

            const results = {
                steps_completed: [],
                errors: [],
                final_report: null
            };

            try {
                // PILLAR 1: Document Processing
                results.steps_completed.push('PILLAR_1_START');

                const documentType = detectDocumentType(text, fileName);
                const normalizedText = normalizeHebrewText(text);
                const definitions = extractDefinitions(normalizedText);
                const category = categorizeTender(normalizedText);

                results.steps_completed.push('PILLAR_1_COMPLETE');

                // PILLAR 2: Gate Conditions Analysis
                results.steps_completed.push('PILLAR_2_START');

                const gatesResult = await extractGateConditionsEnhanced(tenderId, normalizedText, definitions);
                const conditions = gatesResult.conditions || [];

                // Apply dual interpretation to each condition
                for (const condition of conditions) {
                    condition.interpretation = applyDualInterpretation(
                        condition.condition_text,
                        definitions,
                        category.primary
                    );
                }

                // Compare to company profile
                const profileComparison = await compareToCompanyProfile(tenderId, conditions);

                // Generate clarification requests
                const clarifications = generateClarificationRequests(conditions, profileComparison.gaps, definitions);

                // Generate strategic questions
                const strategic = generateStrategicQuestions(conditions, null, category.primary);

                // Generate required documents list
                const requiredDocs = generateRequiredDocumentsList(conditions);

                // Generate assessments
                const assessments = conditions.map(condition => {
                    const match = profileComparison.matches.find(m => m.condition_id === condition.id);
                    return generateRequirementAssessment(condition, match, condition.interpretation);
                });

                results.steps_completed.push('PILLAR_2_COMPLETE');

                // PILLAR 3: Specification & BOQ Analysis
                results.steps_completed.push('PILLAR_3_START');

                const specification = analyzeSpecification(normalizedText);
                const boq = analyzeBOQ(normalizedText);
                const workScope = analyzeWorkScope(specification, boq);
                const discrepancies = detectDiscrepancies(specification, boq);
                const pricingRisks = analyzePricingRisks(boq, discrepancies, workScope);

                results.steps_completed.push('PILLAR_3_COMPLETE');

                // PILLAR 4: Competitor Analysis
                results.steps_completed.push('PILLAR_4_START');

                const winningBids = await collectWinningBids(tenderId, category.primary);
                const competitorMapping = await mapCompetitors(tenderId, category.primary);
                const competitorPricing = analyzeCompetitorPricing(winningBids, boq);
                const competitiveIntel = generateCompetitiveIntelligence(competitorMapping, conditions, null);

                results.steps_completed.push('PILLAR_4_COMPLETE');

                // OUTPUT: Generate Decision Report
                results.steps_completed.push('DECISION_REPORT_START');

                results.final_report = await generateDecisionReport(tenderId);

                results.steps_completed.push('DECISION_REPORT_COMPLETE');

                console.log('[FullAnalysis] Pipeline complete. Steps:', results.steps_completed.length);

            } catch (error) {
                console.error('[FullAnalysis] Error:', error);
                results.errors.push(error.message);
            }

            return results;
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[Dashboard] Initializing...');

            // Set current date
            const dateEl = document.getElementById('current-date');
            if (dateEl) {
                const today = new Date();
                dateEl.textContent = today.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            }

            // Load user info
            await loadUserInfo();

            // Load dashboard data
            await Promise.all([
                loadStats(),
                loadTenders(),
                loadActivity()
            ]);

            // Setup event listeners
            setupEventListeners();
        });

        // ============================================
        // USER INFO
        // ============================================
        async function loadUserInfo() {
            try {
                const supabase = getSupabase();
                if (!supabase || typeof supabase.auth?.getUser !== 'function') {
                    document.getElementById('user-name').textContent = 'Guest';
                    return;
                }

                const { data: { user } } = await supabase.auth.getUser();

                if (user) {
                    const name = user.user_metadata?.full_name || user.email?.split('@')[0] || 'User';
                    document.getElementById('user-name').textContent = name;
                    document.getElementById('user-email').textContent = user.email || '';
                    document.getElementById('user-avatar').textContent = name.charAt(0).toUpperCase();
                } else {
                    document.getElementById('user-name').textContent = 'Guest';
                    document.getElementById('user-email').textContent = 'Not logged in';
                }
            } catch (e) {
                console.log('Error loading user:', e);
                document.getElementById('user-name').textContent = 'Guest';
            }
        }

        // ============================================
        // LOAD STATS
        // ============================================
        async function loadStats() {
            try {
                const supabase = getSupabase();
                if (!supabase || typeof supabase.from !== 'function') {
                    console.log('[Stats] Supabase not ready');
                    setDemoStats();
                    return;
                }

                const { data: tenders, error } = await supabase
                    .from('tenders')
                    .select('*');

                if (error) {
                    console.log('[Stats] Query error:', error.message);
                    setDemoStats();
                    return;
                }

                if (!tenders || tenders.length === 0) {
                    setDemoStats();
                    return;
                }

                updateStatsFromTenders(tenders);

            } catch (e) {
                console.error('Error loading stats:', e);
                setDemoStats();
            }
        }

        function updateStatsFromTenders(tenders) {
            const stats = {
                total: tenders?.length || 0,
                active: tenders?.filter(t => ['active', 'ACTIVE', 'INTAKE', 'GATES_EXTRACTED'].includes(t.status)).length || 0,
                pending: tenders?.filter(t => ['pending', 'analyzing', 'PENDING'].includes(t.status)).length || 0,
                value: tenders?.reduce((sum, t) => sum + (t.estimated_value || 0), 0) || 0
            };

            document.getElementById('stat-total').textContent = stats.total;
            document.getElementById('stat-active').textContent = stats.active;
            document.getElementById('stat-pending').textContent = stats.pending;
            document.getElementById('stat-value').textContent = formatCurrency(stats.value);
        }

        function setDemoStats() {
            document.getElementById('stat-total').textContent = '5';
            document.getElementById('stat-active').textContent = '3';
            document.getElementById('stat-pending').textContent = '2';
            document.getElementById('stat-value').textContent = 'â‚ª2.5M';
        }

        // ============================================
        // LOAD TENDERS
        // ============================================
        async function loadTenders() {
            const list = document.getElementById('tender-list');

            try {
                const supabase = getSupabase();
                if (!supabase || typeof supabase.from !== 'function') {
                    console.log('[Tenders] Supabase not ready');
                    showDemoTenders(list);
                    return;
                }

                const { data: tenders, error } = await supabase
                    .from('tenders')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(10);

                if (error) {
                    console.log('[Tenders] Query error:', error.message);
                    showDemoTenders(list);
                    return;
                }

                if (!tenders || tenders.length === 0) {
                    list.innerHTML = `
                        <li class="empty-state">
                            <div class="empty-state-icon">ğŸ“‹</div>
                            <div class="empty-state-text">××™×Ÿ ××›×¨×–×™× ×¢×“×™×™×Ÿ</div>
                            <div class="empty-state-subtext">×œ×—×¥ ×¢×œ "××›×¨×– ×—×“×©" ×›×“×™ ×œ×”×ª×—×™×œ</div>
                            <button class="btn btn-primary" onclick="openUploadModal()" style="margin-top: 20px;">
                                â• ×”×¢×œ×” ××›×¨×–
                            </button>
                        </li>
                    `;
                    return;
                }

                renderTenders(tenders, list);

            } catch (e) {
                console.error('Error loading tenders:', e);
                showDemoTenders(list);
            }
        }

        function renderTenders(tenders, list) {
            list.innerHTML = tenders.map(tender => {
                const status = tender.status || 'draft';
                const deadline = tender.submission_deadline ? new Date(tender.submission_deadline) : null;
                const daysLeft = deadline ? Math.ceil((deadline - new Date()) / (1000*60*60*24)) : null;
                const isUrgent = daysLeft !== null && daysLeft <= 3;

                return `
                    <li class="tender-item" onclick="viewTender('${tender.id}')">
                        <div class="tender-status ${status}"></div>
                        <div class="tender-info">
                            <div class="tender-name">${tender.tender_name || tender.name || '××›×¨×– ×œ×œ× ×©×'}</div>
                            <div class="tender-meta">${tender.issuing_body || tender.organization || '×’×•×¨× ×œ× ×™×“×•×¢'}</div>
                        </div>
                        <div class="tender-value">
                            <div class="tender-amount">${formatCurrency(tender.estimated_value || 0)}</div>
                            <div class="tender-deadline ${isUrgent ? 'urgent' : ''}">
                                ${deadline ? (daysLeft > 0 ? daysLeft + ' ×™××™×' : '×¤×’ ×ª×•×§×£') : '×œ×œ× ××•×¢×“'}
                            </div>
                        </div>
                    </li>
                `;
            }).join('');
        }

        function showDemoTenders(list) {
            const demoTenders = [
                { id: '1', name: '×©×“×¨×•×’ ×ª×©×ª×™×•×ª IT', org: '××©×¨×“ ×”××•×¦×¨', value: 2500000, status: 'active', days: 5 },
                { id: '2', name: '×¤×¨×•×™×§×˜ ××¢×‘×¨ ×œ×¢× ×Ÿ', org: '×—×‘×¨×ª ×—×©××œ', value: 1800000, status: 'analyzing', days: 12 },
                { id: '3', name: '×”×ª×§× ×ª ××¢×¨×›×ª ××‘×˜×—×”', org: '×¢×™×¨×™×™×ª ×ª×œ ××‘×™×‘', value: 950000, status: 'pending', days: 2 }
            ];

            list.innerHTML = demoTenders.map(t => `
                <li class="tender-item" onclick="viewTender('${t.id}')">
                    <div class="tender-status ${t.status}"></div>
                    <div class="tender-info">
                        <div class="tender-name">${t.name}</div>
                        <div class="tender-meta">${t.org}</div>
                    </div>
                    <div class="tender-value">
                        <div class="tender-amount">${formatCurrency(t.value)}</div>
                        <div class="tender-deadline ${t.days <= 3 ? 'urgent' : ''}">${t.days} ×™××™×</div>
                    </div>
                </li>
            `).join('');
        }

        // ============================================
        // LOAD ACTIVITY
        // ============================================
        async function loadActivity() {
            const list = document.getElementById('activity-list');

            const demoActivity = [
                { icon: 'ğŸ“¤', text: '××›×¨×– ×—×“×© ×”×•×¢×œ×”', time: '×œ×¤× ×™ ×©×¢×ª×™×™×' },
                { icon: 'ğŸ”', text: '× ×™×ª×•×— ×”×•×©×œ×', time: '×œ×¤× ×™ 5 ×©×¢×•×ª' },
                { icon: 'âœ…', text: '×ª× ××™ ×¡×£ × ×‘×“×§×•', time: '××ª××•×œ' }
            ];

            list.innerHTML = demoActivity.map(a => `
                <li class="activity-item">
                    <div class="activity-icon">${a.icon}</div>
                    <div>
                        <div class="activity-text">${a.text}</div>
                        <div class="activity-time">${a.time}</div>
                    </div>
                </li>
            `).join('');
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        function setupEventListeners() {
            // New Tender Button
            document.getElementById('new-tender-btn').addEventListener('click', openUploadModal);

            // Modal Close
            document.getElementById('close-modal').addEventListener('click', closeUploadModal);
            document.getElementById('upload-modal').addEventListener('click', function(e) {
                if (e.target === this) closeUploadModal();
            });

            // Quick Upload Zone
            setupUploadZone('quick-upload-zone', 'quick-file-input');

            // Modal Upload Zone
            setupUploadZone('modal-upload-zone', 'modal-file-input');

            // Start Analysis Button
            document.getElementById('start-analysis-btn').addEventListener('click', startAnalysis);

            // User logout
            document.getElementById('sidebar-user').addEventListener('click', async function() {
                if (confirm('Sign out?')) {
                    const supabase = getSupabase();
                    if (supabase) {
                        await supabase.auth.signOut();
                    }
                    window.location.href = 'tenderix-login.html';
                }
            });
        }

        function setupUploadZone(zoneId, inputId) {
            const zone = document.getElementById(zoneId);
            const input = document.getElementById(inputId);

            if (!zone || !input) return;

            // Click to browse
            zone.addEventListener('click', () => input.click());

            // Drag events
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('drag-over');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileSelect(files[0], zone);
                }
            });

            // File input change
            input.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileSelect(e.target.files[0], zone);
                }
            });
        }

        function handleFileSelect(file, zone) {
            selectedFile = file;

            // Update zone to show file name
            zone.innerHTML = `
                <div class="upload-zone-icon">âœ…</div>
                <div class="upload-zone-text">${file.name}</div>
                <div class="upload-zone-hint">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
            `;

            // If quick upload, open modal
            if (zone.id === 'quick-upload-zone') {
                openUploadModal();
                // Also update modal zone
                document.getElementById('modal-upload-zone').innerHTML = `
                    <div class="upload-zone-icon">âœ…</div>
                    <div class="upload-zone-text">${file.name}</div>
                    <div class="upload-zone-hint">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                `;
            }

            showToast('success', '×§×•×‘×¥ × ×‘×—×¨: ' + file.name);
        }

        // ============================================
        // MODAL FUNCTIONS
        // ============================================
        function openUploadModal() {
            document.getElementById('upload-modal').classList.add('active');
        }

        function closeUploadModal() {
            document.getElementById('upload-modal').classList.remove('active');
        }

        // ============================================
        // UPLOAD & ANALYSIS (Direct to Supabase)
        // ============================================
        async function startAnalysis() {
            if (!selectedFile) {
                showToast('error', '× × ×œ×‘×—×•×¨ ×§×•×‘×¥ ×§×•×“×');
                return;
            }

            const supabase = getSupabase();
            if (!supabase) {
                showToast('error', '×œ× ××—×•×‘×¨ ×œ×“××˜××‘×™×™×¡');
                return;
            }

            const tenderName = document.getElementById('tender-name-input').value || selectedFile.name.replace(/\.[^/.]+$/, '');
            const zone = document.getElementById('modal-upload-zone');
            let extractedText = '';

            try {
                // Step 1: Upload file
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 1/5: ××¢×œ×” ×§×•×‘×¥...</p>
                    </div>
                `;
                console.log('[Upload] Step 1: Uploading file to storage...');

                const timestamp = Date.now();
                const fileExt = selectedFile.name.split('.').pop().toLowerCase();
                const safeFileName = `${timestamp}.${fileExt}`;
                const filePath = `tenders/${safeFileName}`;

                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('tender-documents')
                    .upload(filePath, selectedFile, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (uploadError) {
                    console.error('[Upload] Storage error:', uploadError);
                    throw new Error('×©×’×™××” ×‘×”×¢×œ××ª ×”×§×•×‘×¥: ' + uploadError.message);
                }

                console.log('[Upload] File uploaded:', uploadData.path);

                const { data: urlData } = supabase.storage
                    .from('tender-documents')
                    .getPublicUrl(filePath);

                const fileUrl = urlData?.publicUrl || filePath;
                console.log('[Upload] File URL:', fileUrl);

                // Step 2: Extract text from PDF
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 2/5: ××—×œ×¥ ×˜×§×¡×˜ ××”××¡××š...</p>
                    </div>
                `;
                console.log('[Upload] Step 2: Extracting text from PDF...');

                if (fileExt === 'pdf') {
                    extractedText = await extractTextFromPDF(selectedFile);
                    console.log('[Upload] Extracted', extractedText.length, 'characters');
                }

                // Step 3: Parse metadata
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 3/5: ×× ×ª×— ××˜××“××˜×”...</p>
                    </div>
                `;
                console.log('[Upload] Step 3: Parsing metadata...');

                let metadata = {};
                if (extractedText.length > 100) {
                    metadata = parseTenderMetadata(extractedText, selectedFile.name);
                }

                // Step 4: Create tender record with parsed metadata
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 4/5: ×™×•×¦×¨ ×¨×©×•××ª ××›×¨×–...</p>
                    </div>
                `;
                console.log('[Upload] Step 4: Creating tender record with metadata...');

                const tenderData = {
                    tender_name: metadata.tender_name || tenderName,
                    tender_number: metadata.tender_number || ('TDR-' + timestamp),
                    issuing_body: metadata.issuing_body || null,
                    submission_deadline: metadata.submission_deadline || null,
                    clarification_deadline: metadata.clarification_deadline || null,
                    estimated_value: metadata.estimated_value || null,
                    guarantee_amount: metadata.guarantee_amount || null,
                    // Module 1.2: Scoring weights
                    quality_weight: metadata.quality_weight || null,
                    price_weight: metadata.price_weight || null,
                    contract_duration_months: metadata.contract_duration_months || null,
                    // Scoring method detection
                    scoring_method: (metadata.quality_weight || metadata.price_weight) ? 'WEIGHTED' : null,
                    status: 'INTAKE',
                    current_step: 'ANALYZING',
                    category: 'OTHER',
                    created_at: new Date().toISOString()
                };

                console.log('[Upload] Tender data:', tenderData);

                const { data: tender, error: tenderError } = await supabase
                    .from('tenders')
                    .insert(tenderData)
                    .select()
                    .single();

                if (tenderError) {
                    console.error('[Upload] Tender creation error:', tenderError);
                    throw new Error('×©×’×™××” ×‘×™×¦×™×¨×ª ××›×¨×–: ' + tenderError.message);
                }

                console.log('[Upload] Tender created:', tender.id);

                // Detect document type based on content (Module 1.1)
                const detectedDocType = extractedText.length > 100
                    ? detectDocumentType(extractedText, selectedFile.name)
                    : 'TENDER_INVITATION';
                console.log('[Upload] Detected document type:', detectedDocType);

                // Create document record (without file_size - column doesn't exist in DB)
                const { data: doc, error: docError } = await supabase
                    .from('tender_documents')
                    .insert({
                        tender_id: tender.id,
                        file_name: selectedFile.name,
                        original_filename: selectedFile.name,
                        file_type: selectedFile.type || 'application/pdf',
                        storage_path: filePath,
                        file_url: fileUrl,
                        document_type: detectedDocType,
                        status: 'UPLOADED',
                        created_at: new Date().toISOString()
                    })
                    .select()
                    .single();

                if (docError) {
                    console.error('[Upload] Document record error:', docError);
                } else {
                    console.log('[Upload] Document record created:', doc.id);
                }

                // Step 5: Normalize text (Module 1.3)
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 5/8: ×× ×¨××œ ×˜×§×¡×˜...</p>
                    </div>
                `;
                console.log('[Upload] Step 5: Normalizing Hebrew text...');
                const normalizedText = extractedText.length > 100 ? normalizeHebrewText(extractedText) : extractedText;

                // Step 6: Extract definitions (Module 1.4)
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 6/8: ××—×œ×¥ ×”×’×“×¨×•×ª...</p>
                    </div>
                `;
                console.log('[Upload] Step 6: Extracting definitions...');
                const definitions = extractedText.length > 100 ? extractDefinitions(normalizedText) : [];
                console.log('[Upload] Found', definitions.length, 'definitions');

                // Step 7: Categorize tender (Module 1.5)
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 7/8: ××¡×•×•×’ ××›×¨×–...</p>
                    </div>
                `;
                console.log('[Upload] Step 7: Categorizing tender...');
                const category = extractedText.length > 100 ? categorizeTender(normalizedText) : { primary: 'OTHER' };
                console.log('[Upload] Category:', category.primary);

                // Update tender with category
                if (category.primary !== 'OTHER') {
                    await supabase
                        .from('tenders')
                        .update({ category: category.primary })
                        .eq('id', tender.id);
                }

                // Step 8: Extract gate conditions with enhanced analysis (Module 2.1)
                zone.innerHTML = `
                    <div class="upload-progress">
                        <div class="spinner"></div>
                        <p>×©×œ×‘ 8/8: ×× ×ª×— ×ª× ××™ ×¡×£...</p>
                    </div>
                `;
                console.log('[Upload] Step 8: Extracting gate conditions (enhanced)...');

                let gatesResult = { success: false, count: 0 };
                if (extractedText.length > 100) {
                    gatesResult = await extractGateConditionsEnhanced(tender.id, normalizedText, definitions);
                    console.log('[Upload] Gates extraction result:', gatesResult);

                    // Update tender status
                    await supabase
                        .from('tenders')
                        .update({ current_step: 'GATES_ANALYZED' })
                        .eq('id', tender.id);
                }

                // Success!
                console.log('[Upload] SUCCESS! Tender ID:', tender.id);
                const gatesMsg = gatesResult.count > 0 ? ` (${gatesResult.count} ×ª× ××™ ×¡×£ × ××¦××•)` : '';
                showToast('success', '×”××›×¨×– ×”×•×¢×œ×” ×•× ×•×ª×— ×‘×”×¦×œ×—×”!' + gatesMsg);
                closeUploadModal();

                // Refresh data
                await loadStats();
                await loadTenders();

                // Reset
                selectedFile = null;
                resetUploadZones();
                document.getElementById('tender-name-input').value = '';

                // Navigate to tender detail
                setTimeout(() => {
                    if (confirm('×”××›×¨×– × ×•×¦×¨ ×•× ×•×ª×— ×‘×”×¦×œ×—×”! ×œ×¢×‘×•×¨ ×œ×“×£ ×¤×¨×˜×™ ×”××›×¨×–?')) {
                        viewTender(tender.id);
                    }
                }, 500);

            } catch (e) {
                console.error('[Upload] Failed:', e);
                showToast('error', '×”×¢×œ××” × ×›×©×œ×”: ' + e.message);
                resetUploadZones();
            }
        }

        // Helper function to convert file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // Remove the data URL prefix (e.g., "data:application/pdf;base64,")
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = error => reject(error);
            });
        }

        function resetUploadZones() {
            const defaultContent = `
                <div class="upload-zone-icon">ğŸ“¤</div>
                <div class="upload-zone-text">×’×¨×•×¨ ×•×©×—×¨×¨ ××¡××›×™ ××›×¨×–</div>
                <div class="upload-zone-hint">××• ×œ×—×¥ ×œ×‘×—×™×¨×ª ×§×‘×¦×™×</div>
            `;
            document.getElementById('modal-upload-zone').innerHTML = defaultContent;
            document.getElementById('quick-upload-zone').innerHTML = `
                <div class="upload-zone-icon">ğŸ“„</div>
                <div class="upload-zone-text">×’×¨×•×¨ ×§×•×‘×¥ ××›×¨×– ×œ×›××Ÿ</div>
                <div class="upload-zone-hint">PDF, Word, Excel ×¢×“ 50MB</div>
            `;
        }

        // ============================================
        // VIEW TENDER
        // ============================================
        function viewTender(id) {
            window.location.href = `tenderix-tender-detail.html?id=${id}`;
        }

        // ============================================
        // UTILITIES
        // ============================================
        function formatCurrency(value) {
            if (value >= 1000000) {
                return 'â‚ª' + (value / 1000000).toFixed(1) + 'M';
            } else if (value >= 1000) {
                return 'â‚ª' + (value / 1000).toFixed(0) + 'K';
            }
            return 'â‚ª' + value.toLocaleString();
        }

        function showToast(type, message) {
            const container = document.getElementById('toast-container');
            const icons = { success: 'âœ…', error: 'âŒ', info: 'â„¹ï¸' };

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || 'â„¹ï¸'}</span>
                <span class="toast-message">${message}</span>
            `;

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Global functions
        window.openUploadModal = openUploadModal;
        window.viewTender = viewTender;
    </script>
</body>
</html>
